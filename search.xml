<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java 笔记4]]></title>
    <url>%2F2019%2F04%2F23%2Fjava%E7%AC%94%E8%AE%B04%2F</url>
    <content type="text"><![CDATA[数组1.数组是一个变量，用来储存一组相同数据类型的数据 2.声明一个变量就是在内存空间划出一块适合的空间 3.声明一个数组就是在内存中划出一串连续的空间 4.数组是相同类型数据的有序集合. 5.相同类型的若干个数据,按照一定先后次序排列组合而成。 6.其中,每一个数据称作一个数组元素 7.每个数组元素可以通过一个下标来访问它们. 数组的结构和基本要数*标识符:数组的名称，用于区分不同的数组 *数组元素:向数组中存放的数据 *元素的索引(下标|角标)：对数组元素进行编号 *元素类型：数组元素的数据类型 注意: ​ 1.数组只有一个名称，即标识符 ​ 2.元素索引标明了元素在数组中的位置，下标从0开始 ​ 3.数组中的每个元素都可以通过索引来访问 ​ 4.数组长度固定不变，避免数组索引越界 ​ 5.数组变量属于引用数据类型 数组特点:其长度是确定的。数组一旦被创建，它的大小就是不可以改变的。 其元素必须是相同类型,不允许出现混合类型。 数组中的元素可以是任何数据类型，包括基本类型和引用类型。 位置有顺序 数组属引用类型 length, elements of the array 一维数组的声明方式有两种： ​ 123type[] arr_name;type arr_name[]; 数组初始化动态初始化 数组定义与为数组元素分配空间并赋值的操作分开进行。 123451 int a[] = null;2 a = new int[3];3 a[0] = 3;4 a[1] = 9;5 a[2] = 8; 静态初始化：除了用new关键字来产生数组以外,还可以直接在定义数组的同时就为数组元素分配空间并赋值。 格式: 类型 [] 数组名 = {元素1, 元素2 ……} int [] a = {1, 2, 3, 4, 5}; 静态赋值:就是在程序运行之前,就很明确的知道数组中存放的数据是什么,静态赋值不能先声明后赋值,使用new情况除外 动态初始化： 动态地从键盘录入数组中的元素 12345int [] score = new int[30]; Scanner input = new Scanner(System.in); for (int i = 0; i &lt; 30; i++) &#123; score[i]= input.nextInt() &#125; ​ 数组的界限定义并用运算符new为之分配空间后，才可以引用数组中的每个元素； 数组元素的引用方式： 1arrayName[index] index为数组元素下标，可以是整型常量或整型表达式。如a[3] , b[i] , c[6*i]; 数组元素下标从0开始；长度为n的数组合法下标取值范围： 0 ~ n-1 每个数组都有一个属性length指明它的长度，例如：a.length 指明数组a的长度(元素个数)； 数组的长度: 数组名.length 遍历数组中的元素12345for循环//array.length; 数组中元素的个数for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(array[i]);&#125; 1234567加强for循环//加强for循环 foreach 循环//int 指的是数组中元素的类型//i 是迭代变量,就是临时变量array1 是数组的名字for (int i : array1) &#123;System.out.println(i);&#125; 数组的插入​ 元数组为{12,34,40,65,89},将56插入到数组中,使数组还保持升序 ​ 步骤 [12,34,45,65,89,0] ​ 1,找到第一个大于56的数的下标index, 即为56插入的位置 ​ 2,创建一个新的数组长度为原数组+1,使用循环,将原数组的元素拷贝至新数组 ​ 3,新数组从index开始每个元素都后移一位 ​ 4,将56 插入到index位置 1234567891011121314151617181920212223242526272829303132333435363738package 数组常用的操作;/** * * @author Administrator * */public class Test02 &#123; public static void main(String[] args) &#123; int [] arr01 = &#123;12,34,40,65,89&#125;; //创建一个新的数组，长度为原数组长度加1 int [] arr02 = new int[arr01.length+1]; //将原数组的元素一一拷贝到新数组中 for (int i = 0;i&lt;arr01.length;i++)&#123; arr02[i] = arr01[i]; &#125; //[2]在arr02找到第一个比56大的数组 保存下标 int index = 0; for(int i =0;i&lt;arr02.length;i++)&#123; if (arr02[i] &gt;56)&#123; index = i ; break; &#125; &#125; //[3]从index开始 所有元素都往后移动一位 //[12,34,40,65,89,0] for (int i =arr02.length-1; i&gt; index ;i--)&#123; arr02[i] = arr02[i-1]; &#125; //【4】将56插入到index的位置 arr02[index] = 56; for(int i:arr02)&#123; System.out.println(i); &#125; &#125;&#125; 冒泡排序排序算法 什么是冒泡排序呢? ​ 冒泡排序是计算机领域一种较简单的排序算法。 ​ 它重复地访问要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。访问数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 ​ 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名“冒泡排序” 。 原理: 1.比较相邻的元素。如果第一个比第二个大，就交换他们两个 2.对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数 3.针对所有的元素重复以上的步骤，除了最后一个(因为最后一个是最大的，不需要比较) 4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较(最后一个数不需要比较，因为它是最小的) 什么时候用到排序？ 总结: ​ 升序排列时，比较的时候如果满足条件就交换值，每次可以确定一个最大值。 ​ 不用与每次确定下来的最大值最大值进行比较 ​ 确定了倒数第二打的值，那个最小的值不用与其余的值比较 ​ 有排行榜的位置就涉及到排序，范围之广，用处之多大家可以体会得到排序的重要性 123456789101112131415161718192021222324252627282930public class MaoPao &#123; public static void main(String[] args) &#123; int [] arr = &#123;91,10,31,109,2,33&#125;; for (int i = 0;i &lt; arr.length-1;i++)&#123; //外层循环循环一次 冒出来一个最值 ，长度为n 的数组 冒出来n-1个最值就可以排好序了 //所以判断条件是i &lt; arr.length-1; for (int j = 0;j &lt; arr.length-i-1;j++)&#123; //因为外层循环循环一次就冒出来一个最大值 该最大值就不用在参与比较了 //所以判断条件后面要 -i //又因为在内存循环中每次取出两个元素 一个下标为j 一个下标为j+1 //所以j最大值只能取到arr.length-2; //j+ 1的值最大就是arr.length -1 就是最后一个元素了 int n1 = arr[j]; int n2 = arr[j+1]; //比较两个元素 如果前者大于后者 则交换位置 if(n1 &gt; n2)&#123; arr[j] = n2; arr[j+1] = n1; &#125; &#125; &#125; for(int i :arr)&#123; System.out.println(i); &#125; &#125;&#125; 选择排序什么是选择排序呢? ​ 选择排序是一种简单直观的排序算法。 ​ 用第一个元素依次以后面的比较，满足条件则交换。 ​ 如果是升序每次可以确定一个最小值 ​ 如果是降序每次可以确定一个最大值 升序情况下: ​ 用第一个元素与后面的依次比较以后就可以确定第一个元素是最小值，然后就用第二个元素去比较确定倒数第二小的值，以此类推，比较到倒数第二个元素确定时，最后一个元素就是最大值 12345678910111213int[] a = &#123;9,1,7,5,3&#125;;for(int i = 0;i&lt;a.length -1;i++)&#123; for(int j = i+1;j&lt;a.length;j++)&#123; if(a[i] &gt; a[j])&#123; int temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; &#125;&#125;for(int k : a)&#123; System.out.println(k);&#125; 插入排序原理: ​ 将初始序列中的第一个元素作为一个有序序列，然后将剩下的 n-1 个元素按关键字大小依次插入该有序序列，每插入一个元素后依然保持该序列有序，经过 n-1 趟排序后使初始序列有序 初始序列： 1234567891011int[ ] a = &#123;9,1,7,5&#125;; for(int i = 1;i&lt;a.length;i++)&#123; // 因为值是从第二个位置(索引为1)拿出来的 所以 i 从 1 开始 int temp = a[i]; // 把a[i] 赋值给 temp 变量 int j = i - 1; // j 当作一个索引 ,a[j] 的值就是temp值的前一位值 while(j&gt;=0 &amp;&amp; a[j] &gt; temp)&#123;// a[j] &gt; temp ，把拿出来的值与前面的做比较 a[j+1] = a[j]; // 如果满足条件就把前面的值放到后面来 j--; // j-- , 因为要把拿出来的值依次与前面的值比较， // while里面的 j &gt;=0 ,在这里当 j=0时,j--会索引越界 所以 j&gt;=0 &#125; a[j+1] = temp; // 把拿出来的值放到指定的位置(根据比较的结果来放入)&#125; 二维数组：–实质是每个元素是一维数组的一维数组； 什么是二维数组二维数组本质上是以数组作为数组元素的数组，即“数组的数组”。 二维数组又称为矩阵，行列数相等的矩阵称为方阵 二维数组举例：1int [][] a = &#123;&#123;1,2&#125;,&#123;3,4,0,9&#125;,&#123;5,6,7&#125;&#125;; ​ Java中多维数组不必须是规则矩阵形式 Java中多维数组的声明和初始化应按从高维到低维的顺序进行 编写一应用程序实现下述功能：创建一基本(primitive)数据类型的二维数组并输出各数组元素的值。例如： 12345678910111213141516171819202122package Test;public class erWeishuzu &#123; public static void main(String[] args) &#123; int [][] arr01 = &#123;&#123;1,2,3&#125;,&#123;1,2&#125;,&#123;3,4,5,6&#125;&#125;; //当二维数组中的每一个一位数组长度都相同的时候可以这样声明 int [][] arr02 = new int[3][5]; //当二维数组中的每一个一维数组的长度不确定 int [][] arr03 = new int[3][]; arr03[0] = new int[3]; arr03[1] = new int [2]; arr03[2] = new int [4]; for (int i =0;i&lt; arr01.length;i++)&#123; int [] arr = arr01[i]; for (int j= 0;j&lt; arr.length;j++)&#123; System.out.println(&quot;第&quot;+i+&quot;个一维数组中的第&quot;+j+&quot;个元素是：&quot;+arr[j]); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 笔记2]]></title>
    <url>%2F2019%2F04%2F22%2Fjava%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[•什么是方法–封装在一起来执行操作语句的集合，用来完成某个功能操作 –在某些语言中称为函数或者过程 –特殊的方法main，程序执行的入口 public static void main(String [ ] args){ 实现功能的语句 } –不可能所有的功能都放到main中，需要定义其他方法完成指定功能，需要时调用方法即可。 12345678910111213141516171819202122232425262728293031323334package Test;/** * 2.判断1-100之间有多少个素数并输出所有素数。 * （将判断一个数是否是素数的功能提取成方法， * 在循环中直接调用即可） */public class sushuDemo &#123; public static void main(String[] args) &#123; int count = 0; for (int i =1; i&lt;= 100;i++)&#123; if(isPrime(i))&#123; System.out.println(i); count++; &#125; &#125; System.out.println(&quot;1~100的素数的总数是：&quot;+count); &#125; public static boolean isPrime(int num)&#123; boolean flag =true; int count = 0; int i = 2; if(num ==1)&#123; flag = false; &#125;else&#123; for(i =2;i &lt;=Math.sqrt(num);i++)&#123; if(num%i == 0)&#123; flag = false; return flag; &#125; &#125; &#125; return flag; &#125;&#125; 修饰符：封装性时再讲，决定了方法的工作范围 返回值类型：必选，如果没有返回值，须写void。方法只能返回一个值 方法名： 参数列表：可以0个、1个、多个，需要同时说明类型。称为形式参数 方法体：完成具体功能。如果有返回值，必须有return语句；如果没有返回值，默认最后一条语句是return，可以省略。 方法重载：–一个类中可以定义有相同的名字，但参数不同的多个方法 –调用时，会根据不同的参数表选择对应的方法。 •判断依据 –同一个类 –同一个方法名 –不同：参数列表不同(类型，个数，顺序不同) •注意 –只有返回值不同不构成方法的重载（ int a(String str){}, void a{String i} –只有形参的名称不同，不构成方法的重载 •[1]定义方法可以将功能代码进行封装 •[2]方法只有被调用才会被执行 •[3]方法的出现提高了代码的复用性 •[4]方法中只能调用方法,不可以在方法内部定义方法 *[5]定义方法时,方法的结果应该返回给调用者去处理 方法详细说明 什么是方法？ ​ 我们经常说做事要有方式方法。实现某个目的的具体过程. ​ 例如我们学过 main函数在里面写的排序，求水仙花数等 为什么要用方法？ ​ 例如：有三个人 小明，小华，小红三个人， ​ 老师要求小明把班级语文分数成绩排名 ​ 要求小华把班级数学分数成绩排名 ​ 要求小华把班级英语分数成绩排名 ​ 这个时候都要用到排序，我们此时可以把制作一个排序的方法供他们使用 ​ 这样代码就只用写一次，多次使用，这样就提高了代码的复用性 方法分为两类四种: 12345678&gt; 访问修饰符 是否静态 有无返回值 方法名( 有无参数 )&#123;&gt; &gt; &#125; &gt; //相似与&gt; public static void main(String[] args)&#123;&gt; &gt; &#125;&gt; 一. 无返回值 12345&gt; // 1.无参数无返回值&gt; public static void demo1()&#123;&gt; System.out.println(&quot;我是无参数无返回值&quot;);&gt; &#125;&gt; 1234567&gt; // 1.有参数无返回值&gt; // 何为参数？ f(x)这个函数里面的 x 就叫做参数&gt; public static void demo2(int i)&#123;// int i 就是参数 &gt; System.out.println(i);&gt; &#125;&gt; 练习: 传递一个一维数组，求出最大值。&gt; 1.定义方法的步骤是什么? ​ 定义方法有两个明确: ​ a.是否有返回值 ​ b.是否有未知参，参与运算 2.方法的执行流程是什么? ​ 自己定义的方法不被调用的时候是不会被执行的。 ​ 在主函数里直接写上方法的名字即可(要考虑是否需要参数) 调用者: 主函数，main 执行者: 某一个方法本身 实际参数: 实际参与运算的数据 形式参数: 方法小括号里的变量 二.有返回值 1234567891011&gt; // 1. 无参数有返回值 &gt; // 什么是返回值？ 把void这个关键字改为 数据类型时就说明这个方法是有返回值的&gt; // 怎么返回？ 用 return 关键字， 返回的值的类型与方法上面的数据类型一致&gt; public static int demo3()&#123;&gt; return 5; // 返回值，顾名思义返回的是一个值&gt; &#125;&gt; public static int demo4()&#123;&gt; int a = 5;&gt; return a;&gt; &#125;&gt; 123456&gt; //2.有参数有返回值&gt; public static int demo5(int i)&#123;&gt; &gt; return i;&gt; &#125;&gt; 注意: ​ 其实每一个方法最后一行都有一个return，没有返回值可以省略不写，但系统会帮我们添加一个，其作用就是为了结束方法 ​ 如果手动的写出 return 就不允许带回任意的数据。 1234&gt; public static void test()&#123;&gt; return;&gt; &#125;&gt; 定义及使用方法的注意事项有哪些？ ​ 1.方法不能定义在另外一个方法的里面 ​ 2.写错方法名字 ​ 3.写错了参数列表 ​ 4.方法返回值是void，方法中可以省略return 不写 ​ （return 后面与下面不能有代码） ​ 5.方法返回值类型和return 后面数据类型必须匹配 ​ 6.调用方法的时候，返回值void不能写在输出语句中 练习： addition、subtract、 multiply、division 传递数组排序 方法的重载 什么是方法的重载? ​ 在同一个类中： ​ 方法名相同 ​ 参数列表不同(参数的顺序、个数、类型) ​ 和返回值无关 1234567891011121314151617181920212223&gt; public static void test1()&#123;&gt; &gt; &#125;&gt; public static void test2(int i)&#123;&gt; &gt; &#125;&gt; public static void test3(String name)&#123;&gt; &gt; &#125;&gt; public static void test4(char sex)&#123;&gt; &gt; &#125;&gt; public static void test5(double weight)&#123;&gt; &gt; &#125;&gt; public static void test6(int i,int j)&#123;&gt; &gt; &#125;&gt; public static void test7(int i,String name)&#123;&gt; &gt; &#125;&gt; ..........&gt; 方法参数分两种： ​ 一.基本数据类型 ​ 基本数据类型的变量当做参数传递的时候，是不改变原值 ​ 方法的局部变量会随着方法的执行完毕而被释放 ​ 局部变量: ​ 定义在方法的声明上和 方法体内 ​ 二.引用数据类型 ​ 引用数据类型当做参数传递，其实传递的是地址值，是改变原值 ​ 即使方法执行完毕，但是实体(对象、数组)还在对内存中，所以在主函数里面继续访问的时候，已经是被更改后的值 •什么是递归（recursion） –程序调用自身的编程技巧称为递归。 –一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法 –递归问题的特点 1.一个问题可被分解为若干层简单的子问题 2.子问题和其上层问题的解决方案一致 3.外层问题的解决依赖于子问题的解决 12345678910111213141516171819202122package Test;import java.rmi.dgc.DGC;/** * 4. 编写递归算法程序：一列数的规则如下: * 1、1、2、3、5、8、13、21、34...... * 求数列的第40位数是多少。 * @author Administrator * */public class digui &#123; public static void main(String[] args) &#123; System.out.println(&quot;结果是：&quot;+Dg(2)); &#125; public static int Dg(int i) &#123; if(i &lt;= 0)&#123; return 0; &#125;else if(i&gt;0 &amp;&amp; i&lt;= 2)&#123; return 1; &#125; return Dg(i-1)+Dg(i-2); &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录生活的点点滴滴]]></title>
    <url>%2F2019%2F04%2F20%2F%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[摘要：命里有时终须有，命里无时莫强求。 正文：人的眼睛有5.76亿像素,但却终究看不懂人心. 喵喵喵]]></content>
  </entry>
  <entry>
    <title><![CDATA[java 笔记]]></title>
    <url>%2F2019%2F04%2F20%2Fjava%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[数据类型和运算符 标识符常作用 常量、变量、方法、类和包等的名称 命名规则 必须以字母、_下划线、美元符$开头。 其它部分可以是字母、下划线“_”、美元符“$”和数字的任意组合 大小写敏感，长度无限制。 不可以是Java的关键字。 注意 Java不采用通常语言使用的ASCII字符集 Java采用unicode这样的标准的国际字符集。因此，这里的字母的含义：英文、汉字等等。(不建议大家使用汉字来定义标识符！） 常量和变量常量变量定义 在程序中存在大量的数据来代表程序的状态，其中有些数据在程序的运行过程中值会发生改变，有些数据在程序运行过程中值不能发生改变，这些数据在程序中分别被叫做变量和常量。 变量举例： 在2D游戏程序中，需要代表人物的位置，则需要2个变量，一个是x坐标，一个是y坐标，在程序运行过程中，这两个变量的值会发生改变 常量举例 代表常数，便于程序的修改（例如：圆周率的值） 增强程序的可读性（例如：常量UP、DOWN、LEFT和RIGHT分辨代表上下左右，其数值分别是1、2、3和4） 在实际的程序中，可以根据数据在程序运行中是否发生改变，来选择应该是使用变量代表还是常量代表 数据类型byte：Java中最小的数据类型，在内存中占8位(bit)，即1个字节，取值范围-128~127，默认值0 short：短整型，在内存中占16位，即2个字节，取值范围-32768~32717，默认值0 int：整型，用于存储整数，在内在中占32位，即4个字节，取值范围-2147483648~2147483647，默认值0 long：长整型，在内存中占64位，即8个字节-2^63~2^63-1，默认值0L float：浮点型，在内存中占32位，即4个字节，用于存储带小数点的数字（与double的区别在于float类型有效小数点只有6~7位），默认值0 double：双精度浮点型，用于存储带有小数点的数字，在内存中占64位，即8个字节，默认值0 char：字符型，用于存储单个字符，占16位，即2个字节，取值范围0~65535，默认值为空 boolean：布尔类型，占1个字节，用于判断真或假（仅有两个值，即true、false），默认值false 浮点型变量：float类型：单精度类型，尾数可以精确到7位有效数字，在很多情况下，float类型的精度很难满足需求。 double类型：双精度类型 精度是float类型的两倍，尾数可以精确到16位有效数字，绝大部分应用程序都采用double类型。 注意 浮点常量默认为double。要变为float，需在后面增加F/f. 如： 3.14F 浮点数存在舍入误差，很多数字不能精确表示。如果需要进行不产生舍入误差的精确数字计算，需要使用BigDecimal类。 算术 单目：~（按位取反）、! (取非)、-（负号运算符）、 ++（自增）、 - -（自减）、 双目：+ - * / %（取余） 三目：a&gt;b?true:false 说明：当a大于b的时候，为true（也就是冒号之前的值），否则为false；这整个运算符包括一个关系运算符（可以是“&gt;””&lt;””!=”等等），一个“？”，一个“：”，冒号前后需要有两个或者是值或者是对象。 关系 等于符号:==，不等于符号:!= ，大于符号:&gt;， 小于符号:&lt;，大于等于符号 :&gt;= ，小于等于符号:&lt;= 。 *位与逻辑 位运算符 与（&amp;）、非（~）、或（|）、异或（^） &amp;：双目运算符，运算时均把运算数转换为二进制再做比较，规则：当相同的位上均为1时结果为1，否则结 果为0.如：1010&amp;1101，转为二进制：1111110010&amp;10001001101，比较结果为：1000000转为十进制： 64。所以1010&amp;1101=64； | ：当两边操作数的位有一边为1时，结果为1，否则为0。如1100|1010=1110 ~：0变1,1变0 ^：两边的位不同时，结果为1，否则为0.如1100^1010=0110 逻辑运算符 与（&amp;&amp;）、非（!）、或（||） 赋值 = += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= 基本数据类型的类型转换 在赋值运算或算术运算时，要求数据类型相同，否则要进行类型转换 转换方式： 自动转换 强制转换 除boolean类型外，所有的基本数据类型因为各自的精度不同，赋值时都要考虑这个问题 除boolean类型外，所有的基本数据类型包括：整型，浮点型，字符型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package 类型转换;/** * 基本数据类型的类型转换 * @author tang * * 类型转换分为两种情况 * 一，自动类型转换 * 1，低精度 向高精度转换 * 2，低位向高位转换 * 二，强制类型转换 * 1，高精度向低精度转换 * 可能会损失精度 * 2，高位向低位转换 * 可能会损失大小 * */public class Test &#123; public static void main(String[] args) &#123; int a = 10; float f = 1.23f; f = a; long lo = 123L; //__________________________ int b = 270; byte bt = (byte)b; System.out.println(bt); //00000001 00001110 f = 3.14f; int c = (int)f; System.out.println(c); &#125;&#125;package test;import java.util.Scanner;/** * 练习3:商场推出幸运抽奖活动 根据抽奖规则计算会员卡号各位数字之和为16,则为幸运会员 * @author tang * */public class Test03 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入四位数的会员卡卡号&quot;); //接收到用户输入的卡号 int cardNo = input.nextInt(); //求出卡号千位上的数字 int k = cardNo/1000; //求出卡号百位上的数字 int b = (cardNo%1000)/100; //求出卡号十位上的数字 int s = (cardNo%100)/10; //求出卡号个位上的数字 int g = cardNo%10;// 求和 int sum = k + b + s + g; String message = (sum == 16)?&quot;恭喜你，中奖了！&quot;:&quot;很遗憾，本次没有中奖&quot;; System.out.println(message); ​]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle入门到删库01]]></title>
    <url>%2F2019%2F04%2F20%2Foracle%E5%85%A5%E9%97%A8%E5%88%B0%E5%88%A0%E5%BA%9301%2F</url>
    <content type="text"><![CDATA[oracle 是一种关系型数据库 1.使用scott用户登录，需要先解锁 （1）使用DBA登录 （2）解锁命令：alter user scott account unlock|lock; 常用命令 (a)sqlplus 1.sqlplus /nolog 不登录 匿名连接到数据库 首先做次操作 2.conn scott/tiger@orcl 3.show user 4.set linesize 150 5.set pagesize 20 6.Passw 修改密码 7.conn sys/abc123456@orcl as sysdba (b)alter user scott account unlock (a)统一密码：123 (b)使用管理账号 (c)sqplus 1.spool on 开始写入 1.spool d:/test.txt 写入路径 2.select * from emp; 查询结果 3.spool off 写入完毕 distinct 取出重复数据 出现在distinct 后面的所有字段都是重复的，系统才会认为这些数据是重复数据。 例子：select distinct e.sal from emp e where 后面的条件 – ＝，！＝,&lt;&gt;，&lt;,&gt;,&lt;=,&gt;=,any,some,all – 部门编号不是10的员工 例子：select *from emp e where e.deptno &lt;&gt; 10; – &gt;all（） 相当于是大于最大值 – &gt;some（） 相当于是大于最小值 – &gt; any() 是查询最大和最小值之间 例子：select * from emp e where e.sal &gt; any(2000,5000); is null 和 is not null – oracle 中 null ！= null – 所以判断某个字段是否为null 要用 is null 或 is not null – 查询奖金不为空的员工 例子：select *from emp e where e.comm is not null between x and y –查询薪资处于1000-2000之间的员工 例子：select *from emp e where e.sal between 1000 and 2000 in（list），not in（list） –查询部门编号不是10 和 20的员工 例子：select e.*from emp e where e.deptno not in(10,20) exists（sub－query） 子查询有数据则表达式返回true 则执行exists前面的查询语句 select from emp e where exists(select from emp e where 1 = 2) like _ ,%,escape ‘\‘ _\% escape ‘\’ – 将所有名字是以s开头的员工查询出来 – 模糊查询 _ 代表有一个不确定的字符 – % 有多个不确定的字符 列子：select e.ename from emp e where e.ename like ‘%\%%’ escape ‘\’ oracle里面的转义符是自定义的，用escape来定义自己想要的转义符 or 和 and –列出deptno为10或者30，并且工资&gt;2000的所有人。 – and 的优先级高于 or 例子：select *from emp e where (e.deptno = 10 or e.deptno = 30) and e.sal &gt; 2000 order by 按照单个列排序 –order by col 降序和升序 –order by col desc (asc) 按照多个列排序（优先级） –order by col1 desc(asc), col2 desc(asc) –union all 全集 不会去除重复数据 ​ select * from emp e where e.deptno = 10 ​ union all ​ select * from emp e where e.sal &gt; 2000 –union 并集（去重） ​ select * from emp e where e.deptno = 10 ​ union ​ select * from emp e where e.sal &gt; 2000 –intersect 交集 ​ select * from emp e where e.deptno = 10 ​ intersect ​ select * from emp e where e.sal &gt; 2000 –minus 差集 ​ select * from emp e where e.deptno = 10 ​ minus ​ select * from emp e where e.sal &gt; 2000 （NVL(comm,0) comm取空值时用0替代） 例子： select e.ename,(e.sal+nvl(e.comm,0))*12 年收入 from emp e 字符函数 – dual 称之为虚表 用于检测查询语句的语法 – 拼接两个字符串 select concat(‘hello’, ‘nihao’) from dual – 首字母大写 select initcap(e.ename) from emp e – 字符搜索 select instr(‘abcda’,’a’,1,2) from dual –字符串左填充 select lpad(‘abc’,10,’#’) from dual –字符串右填充 select rpad(‘abc’,10,’#’) from dual 日期函数 – 返回系统当前日期 例子：select sysdate from dual – 返回指定月数后的日期 例子：select e.ename,e.hiredate 入职日期,add_months(e.hiredate,6) 转正日期 from emp e – 获取本月最后一天的日期 select last_day(sysdate) from dual – 获取最近的周日 月初 年初 select sysdate 当时日期, round(sysdate) 最近0点日期, round(sysdate,’day’) 最近星期日, round(sysdate,’month’) 最近月初, round(sysdate,’q’) 最近季初日期, round(sysdate,’year’) 最近年初日期 from dual; – 获取本周周日 本月月初 本年年初 select sysdate 当时日期, trunc(sysdate) 今天日期, trunc(sysdate,’day’) 本周星期日, trunc(sysdate,’month’) 本月初, trunc(sysdate,’q’) 本季初日期, trunc(sysdate,’year’) 本年初日期 from dual; — 转换函数 将数字转换为字符串 — 参数1 需要转换为字符串的数字 — 参数2 是规定转换得到的字符串的格式 select to_char(12345,’99,999.99’) from dual – 将日期转换为字符串 select to_char(sysdate,’yyyy-MM-dd HH:mi:ss’) from dual ; select to_char(sysdate,’d’) from dual; – to_date 将表示日期的字符串转换为日期类型 select to_date(‘2018年11月8日’,’YYYY”年”MM”月”DD”日”‘) from dual select to_date(‘2018-11-8’,’YYYY-MM-DD’) from dual Select to_date(‘04,05,19,10,23,40’,’yy,mm,dd,hh12,mi,ss’) from dual; – to_number select to_number(‘$123,456’,’999,999’) from dual — 单行函数嵌套 — 没有上司的人 写为boss select e.ename,nvl(to_char(e.mgr),’boss’) from emp e where e.mgr is null]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 笔记3]]></title>
    <url>%2F2019%2F04%2F20%2Fjava%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[​ 流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块。其流程控制方式采用结构化程序设计中规定的三种基本流程结构，即：顺序结构、分支结构和循环结构，如下图所示： 图示： ​ ​​ if单分支选择结构​ if语句对条件表达式进行一次测试，若测试为真，则执行下面的语句，否则跳过该语句​​ 图示： 12 12345678910111213141516171819202122package ifdemo;public class Test &#123; public static void main(String[] args) &#123; double n1 = 6*Math.random(); double n2 = 6*Math.random(); double n3 = 6*Math.random(); int sum = (int)(n1 + n2 + n3); if (sum &gt;= 15) &#123; System.out.println(&quot;今天手气不错&quot;); &#125; if (sum &gt;= 10 &amp;&amp; sum &lt; 15) &#123; System.out.println(&quot;今天手气一般&quot;); &#125; if (sum &lt; 10) &#123; System.out.println(&quot;今天手气不好&quot;); &#125; System.out.println(&quot;今日运势:&quot;+sum); &#125; if-else**双分支选择结构**当条件表达式为真时，执行语句块1，否则，执行语句块2。也就是else部分图示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package ifdemo;import java.util.Scanner;/**抽奖说明 会员号的百位数字和随机数相等 则会幸运会员 输出 XXXX会员,您是幸运会员,否则输出 XXXX 谢谢您的支持 * @author tang * */public class Test02 &#123; public static void main(String[] args) &#123; //创建一个Scanner的变量 用于输入会员卡卡号 Scanner input = new Scanner(System.in); System.out.println(&quot;请输入会员卡卡号&quot;); int no = input.nextInt(); //获取会员卡百位数字 213 int b = (no%1000)/100; //生成一个0~9的随机数 int number = (int)(10*Math.random()); //判断会员卡卡号百位数字是否和随机数相等 if (b == number) &#123; System.out.println(no+&quot;恭喜您，中奖了&quot;); &#125;else &#123; System.out.println(no+&quot;很遗憾没中奖.谢谢惠顾&quot;); &#125; System.out.println(&quot;程序结束&quot;); &#125;&#125;——————————package ifdemo;import java.util.Scanner;/**小孩搬桌子: 年龄大于7岁可以搬桌子了,大于5岁且为男孩,也可以搬桌子了 否则不可以搬动桌子 你还太年轻了 * @author tang * */public class Test03 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入年龄&quot;); //输入年两 int age = input.nextInt(); System.out.println(&quot;请选择性别:1,男 2,女&quot;); //输入性别 int gender = input.nextInt(); if (age &gt;= 7) &#123; System.out.println(&quot;可以搬桌子&quot;); &#125; if (age &gt;= 5 &amp;&amp; age &lt; 7) &#123; if (gender == 1) &#123; System.out.println(&quot;五岁到七岁之间的男孩可以搬桌子&quot;); &#125;else &#123; System.out.println(&quot;五岁到七岁之间的女孩不可以搬桌子&quot;); &#125; &#125; if (age &lt; 5) &#123; System.out.println(&quot;你不可以搬桌子，太年轻&quot;); &#125; &#125;&#125; If-else if-else**多分支选择结构**if(布尔表达式1) { 语句块1； } else if(布尔表达式2) { 语句块2； }……… else if(布尔表达式n){ ​ 语句块n; } else { ​ 语句块n+1; } 逐条if语句进行判断，条件匹配，进入语句体，否则对if语句继续匹配 1234567891011121314151617181920212223242526272829303132333435363738package ifelseif;import java.util.Scanner;/** * 0~3 婴儿 好好吃奶 * 3~5 儿童 好好玩 * 6~22 少年 好好学习 * 23~60 中年 好好挣钱 * 60~80 中老年 好好补钙 * 80~ 老年 好好晒太阳 * @author tang * * 6~23 精力旺盛 时间充足 财力不足 * 24~60 精力旺盛 时间不足 财力充足 * 60~ 精力不足 时间充足 财力充足 */public class IfElseIf &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入年龄&quot;); int age = input.nextInt(); if (age &lt;= 3) &#123; System.out.println(&quot;婴儿，应该好好吃奶&quot;); &#125;else if(age &lt; 6)&#123; System.out.println(&quot;儿童，好好玩&quot;); &#125;else if(age &lt; 22)&#123; System.out.println(&quot;少年，要好好学习&quot;); &#125;else if(age &lt;= 60)&#123; System.out.println(&quot;中年，要好好工作&quot;); &#125;else if (age &lt;= 80) &#123; System.out.println(&quot;中老年，要补钙&quot;); &#125;else &#123; System.out.println(&quot;老年人，多晒晒太阳&quot;); &#125; System.out.println(&quot;程序结束&quot;); &#125;&#125; while**循环** 在循环刚开始时，会计算一次“布尔表达式”的值，若条件为真，执行循环体。而对于后来每一次额外的循环，都会在开始前重新计算一次。 语句中应有使循环趋向于结束的语句，否则会出现无限循环–––”死”循环。 图示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package whiledemo;/** * 循环4要素 * 1，初始化 * 2，条件判断 * 3，循环体 * 4，迭代 * @author tang * */public class WhileDemo &#123; public static void main(String[] args) &#123; int i = 0;//初始化操作 while(i &lt; 1000)&#123;//条件判断的操作 //循环体 System.out.println(i); //迭代 就是让条件判断趋向于false的操作 i ++; &#125; System.out.println(&quot;程序结束&quot;); &#125;&#125; ---------package test;import java.util.Scanner;/** * 练习3:商场推出幸运抽奖活动 根据抽奖规则计算会员卡号各位数字之和为16,则为幸运会员 * @author tang * */public class Test03 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入四位数的会员卡卡号&quot;); //接收到用户输入的卡号 int cardNo = input.nextInt(); //求出卡号千位上的数字 int k = cardNo/1000; //求出卡号百位上的数字 int b = (cardNo%1000)/100; //求出卡号十位上的数字 int s = (cardNo%100)/10; //求出卡号个位上的数字 int g = cardNo%10;// 求和 int sum = k + b + s + g; String message = (sum == 16)?&quot;恭喜你，中奖了！&quot;:&quot;很遗憾，本次没有中奖&quot;; System.out.println(message); &#125;&#125; switch**多分支选择结构**根据表达式值的不同执行许多不同的操作 switch (表达式) { case 值1 : 语句序列; [break]; case 值2: 语句序列; [break] ; ​ … … … … … [default: 默认语句 ;] } 1.switch语句会根据表达式的值从相匹配的执行，一直执行到break标签处 语句处或者是switch语句的末尾。与任一case值不匹配，则进入default语句(如果有的话) 2.只能处理等值条件判断的情况，且表达式必须为byte，short，int或char类型 ，String 不能是double,float. long 3.常量值必须是与表达式类型兼容的特定的一个常量 4.不允许有重复的case值 5.default子句为可选 123456789101112131415161718192021222324252627282930package switchdemo;/** * 随机生成一个字母，并且判断该字母的类型 * * @author tang * */public class Test &#123; public static void main(String[] args) &#123; int n = (int)(26*Math.random());//产生一个[0,25)的随机数 char flg = (char)(97+n);//产生一个字母 switch (flg) &#123; case &apos;a&apos;: case &apos;e&apos;: case &apos;i&apos;: case &apos;o&apos;: case &apos;u&apos;: System.out.println(&quot;产生了一个元音字母&quot;+flg); break; case &apos;w&apos;: case &apos;y&apos;: System.out.println(&quot;产生了一个半元音字母&quot;+flg); break; default: System.out.println(&quot;产生了一个辅音字母&quot;+flg); break; &#125; &#125;&#125; do-while:先执行，后判断。 while: 先判断，后执行。 While和dowhile的区别： Dowhile总是保证循环体会被至少执行一次！这是他们的主要差别 图示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package Test;import java.util.Scanner;/** * 从键盘输入某个十进制小数，转换成对应的二进制小数并输出。 * @author Administrator * */public class D2Bpoint &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入一个十进制的小数：&quot;); double d = input.nextDouble(); double mul = d; StringBuffer buffer = new StringBuffer(&quot;0&quot;); int count = 0; do&#123; double result = mul*2; int i = (int)result; buffer.append(i); count++; if(count == 7)&#123; break; &#125; mul = result - i; &#125;while(mul != 0); System.out.println(d+ &quot;转化成二进制小数位：&quot;+buffer); &#125;&#125;---------package Test;/** * 6.从键盘输入某个十进制整数数，转换成对应的二进制整数并输出。 * @author Administrator *用2整除十进制整数，可以得到一个商和余数；再用2去除商， *又会得到一个商和余数，如此进行，直到商为小于1时为止， *然后把先得到的余数作为二进制数的低位有效位， *后得到的余数作为二进制数的高位有效位，依次排列起来。 */import java.util.Scanner; public class Test10to2 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入一个十进制的整数：&quot;); int num = input.nextInt(); int num2 = num; String str = &quot;&quot;; do&#123; int div = num/2 ; int mod = num%2 ; str = mod + str; num = div; &#125;while(num != 0); System.out.println(num2+&quot;转换成二进制为：&quot;+str); &#125; &#125; for循环 •for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构 •语法形式 • for (初始表达式;布尔表达式;步进) { –循环体； •} •注意事项 –for循环在执行条件测试后，先执行程序部分，再执行步进。 –在for语句的初始化部分声明的变量，其作用域为整个for循环体 –“初始化”和“循环条件表达式”部分可以使用逗号来执行多个操作 –如果三个部分都为空语句（分号不能省），相当于一个无限循环 跳转语句—break和continue •在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中剩余的语句。(break语句还可用于多支语句switch中) •continue 语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。 跳转语句 —return return语句从当前方法退出，返回到调用该方法的语句处，并从该语句的下条语句处继续执行程序。 返回语句的两种格式（具体到方法时详细讲解） 1、return expression 返回一个值给调用该方法的语句。 返回值的数据类型必须和方法声明中的返回值类型一致或是精度低于声明的数据类型。 2、return 当方法声明中用void声明返回类型为空时，应使用这种返回类型，它不返回任何值。 •break –switch语句–循环语句 •continue –循环语句 •return–任何语句中，结束当前方法，和循环其实没有什么关系 •Continue 只能用于循环中 while do-while 执行了continue 以后 代码回到执行判断的地方,重新判断是否决定下一次执行 •在for循环中执行continue 直接跳到i++迭代处 多重循环（循环嵌套） 一个循环体内又包含另一个完整的循环结构 任何两种循环都可以相互嵌套 可以任意层次循环，但是一般不超过3层 多重循环执行过程 外层循环变量变化一次，内层循环变量要变化一遍 12345678910111213141516171819202122232425262728293031323334package duochongxunhuan;import java.awt.Choice;import java.util.Scanner;/**- 有5家衣服专卖店，每家最多购买3件。用户可以选择离开，可以买衣服。最后打印总共买了几件衣服 思路 外层循环控制去每个专卖店 内层循环控制买衣服过程 使用break退出内层循环- @author Administrator * */ public class BreakDemo &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int count = 0; for (int i = 1;i &lt; 5; i++)&#123; System.out.println(&quot;欢迎光临第&quot;+ i +&quot;家专卖店&quot;); for(int j = 0;j &lt; 3;j++ )&#123; System.out.print(&quot;要离开吗？（y/n)?&quot;); String choice = input.nextLine(); if(&quot;y&quot;.equals(choice))&#123; break; &#125; System.out.println(&quot;买了一件衣服&quot;); count++; &#125; System.out.println(&quot;离店结账&quot;); System.out.println(&quot; &quot;); &#125; System.out.println(&quot;总共买了&quot;+count+&quot;件衣服&quot;); &#125; &#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
