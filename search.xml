<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java入门到入坟02]]></title>
    <url>%2F2019%2F04%2F20%2Fjava%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F02%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[java入门到入坟01]]></title>
    <url>%2F2019%2F04%2F20%2Fjava%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F%2F</url>
    <content type="text"><![CDATA[数据类型和运算符 标识符常作用 常量、变量、方法、类和包等的名称 命名规则 必须以字母、_下划线、美元符$开头。 其它部分可以是字母、下划线“_”、美元符“$”和数字的任意组合 大小写敏感，长度无限制。 不可以是Java的关键字。 注意 Java不采用通常语言使用的ASCII字符集 Java采用unicode这样的标准的国际字符集。因此，这里的字母的含义：英文、汉字等等。(不建议大家使用汉字来定义标识符！） 常量和变量常量变量定义 在程序中存在大量的数据来代表程序的状态，其中有些数据在程序的运行过程中值会发生改变，有些数据在程序运行过程中值不能发生改变，这些数据在程序中分别被叫做变量和常量。 变量举例： 在2D游戏程序中，需要代表人物的位置，则需要2个变量，一个是x坐标，一个是y坐标，在程序运行过程中，这两个变量的值会发生改变 常量举例 代表常数，便于程序的修改（例如：圆周率的值） 增强程序的可读性（例如：常量UP、DOWN、LEFT和RIGHT分辨代表上下左右，其数值分别是1、2、3和4） 在实际的程序中，可以根据数据在程序运行中是否发生改变，来选择应该是使用变量代表还是常量代表 数据类型byte：Java中最小的数据类型，在内存中占8位(bit)，即1个字节，取值范围-128~127，默认值0 short：短整型，在内存中占16位，即2个字节，取值范围-32768~32717，默认值0 int：整型，用于存储整数，在内在中占32位，即4个字节，取值范围-2147483648~2147483647，默认值0 long：长整型，在内存中占64位，即8个字节-2^63~2^63-1，默认值0L float：浮点型，在内存中占32位，即4个字节，用于存储带小数点的数字（与double的区别在于float类型有效小数点只有6~7位），默认值0 double：双精度浮点型，用于存储带有小数点的数字，在内存中占64位，即8个字节，默认值0 char：字符型，用于存储单个字符，占16位，即2个字节，取值范围0~65535，默认值为空 boolean：布尔类型，占1个字节，用于判断真或假（仅有两个值，即true、false），默认值false 浮点型变量：float类型：单精度类型，尾数可以精确到7位有效数字，在很多情况下，float类型的精度很难满足需求。 double类型：双精度类型 精度是float类型的两倍，尾数可以精确到16位有效数字，绝大部分应用程序都采用double类型。 注意 浮点常量默认为double。要变为float，需在后面增加F/f. 如： 3.14F 浮点数存在舍入误差，很多数字不能精确表示。如果需要进行不产生舍入误差的精确数字计算，需要使用BigDecimal类。 算术 单目：~（按位取反）、! (取非)、-（负号运算符）、 ++（自增）、 - -（自减）、 双目：+ - * / %（取余） 三目：a&gt;b?true:false 说明：当a大于b的时候，为true（也就是冒号之前的值），否则为false；这整个运算符包括一个关系运算符（可以是“&gt;””&lt;””!=”等等），一个“？”，一个“：”，冒号前后需要有两个或者是值或者是对象。 关系 等于符号:==，不等于符号:!= ，大于符号:&gt;， 小于符号:&lt;，大于等于符号 :&gt;= ，小于等于符号:&lt;= 。 *位与逻辑 位运算符 与（&amp;）、非（~）、或（|）、异或（^） &amp;：双目运算符，运算时均把运算数转换为二进制再做比较，规则：当相同的位上均为1时结果为1，否则结 果为0.如：1010&amp;1101，转为二进制：1111110010&amp;10001001101，比较结果为：1000000转为十进制： 64。所以1010&amp;1101=64； | ：当两边操作数的位有一边为1时，结果为1，否则为0。如1100|1010=1110 ~：0变1,1变0 ^：两边的位不同时，结果为1，否则为0.如1100^1010=0110 逻辑运算符 与（&amp;&amp;）、非（!）、或（||） 赋值 = += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= 基本数据类型的类型转换 在赋值运算或算术运算时，要求数据类型相同，否则要进行类型转换 转换方式： 自动转换 强制转换 除boolean类型外，所有的基本数据类型因为各自的精度不同，赋值时都要考虑这个问题 除boolean类型外，所有的基本数据类型包括：整型，浮点型，字符型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package 类型转换;/** * 基本数据类型的类型转换 * @author tang * * 类型转换分为两种情况 * 一，自动类型转换 * 1，低精度 向高精度转换 * 2，低位向高位转换 * 二，强制类型转换 * 1，高精度向低精度转换 * 可能会损失精度 * 2，高位向低位转换 * 可能会损失大小 * */public class Test &#123; public static void main(String[] args) &#123; int a = 10; float f = 1.23f; f = a; long lo = 123L; //__________________________ int b = 270; byte bt = (byte)b; System.out.println(bt); //00000001 00001110 f = 3.14f; int c = (int)f; System.out.println(c); &#125;&#125;package test;import java.util.Scanner;/** * 练习3:商场推出幸运抽奖活动 根据抽奖规则计算会员卡号各位数字之和为16,则为幸运会员 * @author tang * */public class Test03 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入四位数的会员卡卡号&quot;); //接收到用户输入的卡号 int cardNo = input.nextInt(); //求出卡号千位上的数字 int k = cardNo/1000; //求出卡号百位上的数字 int b = (cardNo%1000)/100; //求出卡号十位上的数字 int s = (cardNo%100)/10; //求出卡号个位上的数字 int g = cardNo%10;// 求和 int sum = k + b + s + g; String message = (sum == 16)?&quot;恭喜你，中奖了！&quot;:&quot;很遗憾，本次没有中奖&quot;; System.out.println(message); ​]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[oracle入门到删库01]]></title>
    <url>%2F2019%2F04%2F20%2Foracle%E5%85%A5%E9%97%A8%E5%88%B0%E5%88%A0%E5%BA%9301%2F</url>
    <content type="text"><![CDATA[oracle 是一种关系型数据库 1.使用scott用户登录，需要先解锁 （1）使用DBA登录 （2）解锁命令：alter user scott account unlock|lock; 常用命令 (a)sqlplus 1.sqlplus /nolog 不登录 匿名连接到数据库 首先做次操作 2.conn scott/tiger@orcl 3.show user 4.set linesize 150 5.set pagesize 20 6.Passw 修改密码 7.conn sys/abc123456@orcl as sysdba (b)alter user scott account unlock (a)统一密码：123 (b)使用管理账号 (c)sqplus 1.spool on 开始写入 1.spool d:/test.txt 写入路径 2.select * from emp; 查询结果 3.spool off 写入完毕 distinct 取出重复数据 出现在distinct 后面的所有字段都是重复的，系统才会认为这些数据是重复数据。 例子：select distinct e.sal from emp e where 后面的条件 – ＝，！＝,&lt;&gt;，&lt;,&gt;,&lt;=,&gt;=,any,some,all – 部门编号不是10的员工 例子：select *from emp e where e.deptno &lt;&gt; 10; – &gt;all（） 相当于是大于最大值 – &gt;some（） 相当于是大于最小值 – &gt; any() 是查询最大和最小值之间 例子：select * from emp e where e.sal &gt; any(2000,5000); is null 和 is not null – oracle 中 null ！= null – 所以判断某个字段是否为null 要用 is null 或 is not null – 查询奖金不为空的员工 例子：select *from emp e where e.comm is not null between x and y –查询薪资处于1000-2000之间的员工 例子：select *from emp e where e.sal between 1000 and 2000 in（list），not in（list） –查询部门编号不是10 和 20的员工 例子：select e.*from emp e where e.deptno not in(10,20) exists（sub－query） 子查询有数据则表达式返回true 则执行exists前面的查询语句 select from emp e where exists(select from emp e where 1 = 2) like _ ,%,escape ‘\‘ _\% escape ‘\’ – 将所有名字是以s开头的员工查询出来 – 模糊查询 _ 代表有一个不确定的字符 – % 有多个不确定的字符 列子：select e.ename from emp e where e.ename like ‘%\%%’ escape ‘\’ oracle里面的转义符是自定义的，用escape来定义自己想要的转义符 or 和 and –列出deptno为10或者30，并且工资&gt;2000的所有人。 – and 的优先级高于 or 例子：select *from emp e where (e.deptno = 10 or e.deptno = 30) and e.sal &gt; 2000 order by 按照单个列排序 –order by col 降序和升序 –order by col desc (asc) 按照多个列排序（优先级） –order by col1 desc(asc), col2 desc(asc) –union all 全集 不会去除重复数据 ​ select * from emp e where e.deptno = 10 ​ union all ​ select * from emp e where e.sal &gt; 2000 –union 并集（去重） ​ select * from emp e where e.deptno = 10 ​ union ​ select * from emp e where e.sal &gt; 2000 –intersect 交集 ​ select * from emp e where e.deptno = 10 ​ intersect ​ select * from emp e where e.sal &gt; 2000 –minus 差集 ​ select * from emp e where e.deptno = 10 ​ minus ​ select * from emp e where e.sal &gt; 2000 （NVL(comm,0) comm取空值时用0替代） 例子： select e.ename,(e.sal+nvl(e.comm,0))*12 年收入 from emp e 字符函数 – dual 称之为虚表 用于检测查询语句的语法 – 拼接两个字符串 select concat(‘hello’, ‘nihao’) from dual – 首字母大写 select initcap(e.ename) from emp e – 字符搜索 select instr(‘abcda’,’a’,1,2) from dual –字符串左填充 select lpad(‘abc’,10,’#’) from dual –字符串右填充 select rpad(‘abc’,10,’#’) from dual 日期函数 – 返回系统当前日期 例子：select sysdate from dual – 返回指定月数后的日期 例子：select e.ename,e.hiredate 入职日期,add_months(e.hiredate,6) 转正日期 from emp e – 获取本月最后一天的日期 select last_day(sysdate) from dual – 获取最近的周日 月初 年初 select sysdate 当时日期, round(sysdate) 最近0点日期, round(sysdate,’day’) 最近星期日, round(sysdate,’month’) 最近月初, round(sysdate,’q’) 最近季初日期, round(sysdate,’year’) 最近年初日期 from dual; – 获取本周周日 本月月初 本年年初 select sysdate 当时日期, trunc(sysdate) 今天日期, trunc(sysdate,’day’) 本周星期日, trunc(sysdate,’month’) 本月初, trunc(sysdate,’q’) 本季初日期, trunc(sysdate,’year’) 本年初日期 from dual; — 转换函数 将数字转换为字符串 — 参数1 需要转换为字符串的数字 — 参数2 是规定转换得到的字符串的格式 select to_char(12345,’99,999.99’) from dual – 将日期转换为字符串 select to_char(sysdate,’yyyy-MM-dd HH:mi:ss’) from dual ; select to_char(sysdate,’d’) from dual; – to_date 将表示日期的字符串转换为日期类型 select to_date(‘2018年11月8日’,’YYYY”年”MM”月”DD”日”‘) from dual select to_date(‘2018-11-8’,’YYYY-MM-DD’) from dual Select to_date(‘04,05,19,10,23,40’,’yy,mm,dd,hh12,mi,ss’) from dual; – to_number select to_number(‘$123,456’,’999,999’) from dual — 单行函数嵌套 — 没有上司的人 写为boss select e.ename,nvl(to_char(e.mgr),’boss’) from emp e where e.mgr is null]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[“2019.4.19你好”]]></title>
    <url>%2F2019%2F04%2F19%2F%E2%80%9C2019-4-19%E4%BD%A0%E5%A5%BD%E2%80%9D%2F</url>
    <content type="text"></content>
  </entry>
</search>
