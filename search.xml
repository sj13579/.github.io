<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java笔记12]]></title>
    <url>%2F2019%2F05%2F17%2Fjava%E7%AC%94%E8%AE%B012%2F</url>
    <content type="text"><![CDATA[线程的概念程序：Program,是一个指令的集合 进程：Process（正在执行的程序）是一个静态的概念 进程是程序的一次静态的执行过程 占用特定的地址空间 每个空间都是独立的 ，由三个部分组成 c p u , data , code 缺点：内存的浪费 c p u 的负担 线程：是进程中的一个 “单一的连续控制流程”（a singles Thread, equential flow of control)/执行路径 1.线程又被称为轻量级进程。 2.一个进程可拥有多个并行的线程 3.一个进程中的线程共享相同的内存单元 /内存地址空间 —&gt;可以访问相同的变量和对象，而且他们从同一堆中分配对象–&gt;通信、数据的交换、同步操作。 4.由于线程间的通信是在同一地址空间中进行的，所以 不需要额外的通信机制，这就使得通信更简便而且信息的传递速度额更快。 5.java虚拟机启动的时候会有一个进程java.exe，该进程至少有一个进程，在负责java程序的执行。而且这个线程运行的代码存在于main方法中，该线程称之为主线程。 6.一个进程中的线程共享代码和数据空间。 7.线程结束，进程未必结束，但进程结束，线程一定结束 8.进程中包含线程，线程是进程的一部分。 线程的执行d.run()；//仅仅是对象调用方法，而是创建了线程但没有执行 d.start()；//开启线程并执行该线程的run方法 新生状态： 用new关键字建立一个线程后，该线程就处于新生状态 处于新生状态的线程有自己的内存空间，通过调用start（）方法进入就绪状态 就绪状态： 处于就绪状态线程具备了 运行条件，但没有分配到CPU，处于线程就绪队列 等待系统为其分配CPU 当系统选定一个等待执行的线程后，他就从就绪状态回到执行状态。 运行状态： 在运行状态的线程执行自己的run方法中的代码 直到等待某资源而阻塞或完成任何而死亡。 如果在给定的时间片段没有执行结束，就被系统给换下来回到等待执行的状态。 阻塞状态： 处于运行状态的线程在某些情况下，如执行了sleep（睡眠）方法，或等待I/o设备的资源，将让出CPU并暂时停止自己的运行，进入阻塞状态 在阻塞状态的线程不能进入就绪队列，只有当引起阻塞的原因消除时，如睡眠的时间已到，或等待的I/O设备空闲下来，线程便转入就绪状态，重新道就绪状态，重新到就绪列中排队等待，被系统选中后从原来的停止的位置开始继续执行 死亡状态： 死亡状态是线程生命周期中的最后一个阶段，线程死亡的原因有三个，一个是正常运行的线程完成了它的全部工作；另一个是线程 被强制性的终止，如通过stop方法来终止一个线程{不推荐使用}；三是线程抛出未捕获的异常。 12345678public static Thread currentThread() 返回目前正在执行的线程public final String getName() 返回线程的名称public final int getPriority() 返回线程的优先级public final void setPriority(int i) 设定线程的优先级public final boolean isAlive() 判断线程是否在活动 如果是 返回true 否则返回 falsepublic final void join() 调用该方法的线程强制执行，其它线程处于阻塞状态，该线程执行完毕后，其他现场线程再执行public static void sleep(long millis) 使用当前正在执行的线程休眠millis 秒，线程处于阻塞状态public static void yield () 当前执行的线程暂停一次 允许其他的线程执行，不阻塞 线程进入就绪状态 如果没有其他等待执行的线程 这个时候当前线程就会马上执行。 阻塞状态： sleep ：不会释放锁 sleep时别的线程也不可以访问锁定的对象 yield： 让出CPU的使用权 从运行态直接进入就绪态。让CPU重新挑选哪一个线程进入允许状态 join： 当某个线程等待另一个线程执行结束后，才继续执行时，使调用该方法的线程在此之前执行完毕，也就是等待调用该方法的线程执行完毕后再往下继续执行 同步的前提是： 1、必须有两个或两个以上的进程 2、必须是多个线程使用同一资源 3、必须保证同步中只能有一个线程在运行 线程同步小结：同步监视器 synchronized (obj){}中的obj为同步监视器 同步代码块中同步监视器可以是任何对象 但是推荐使用共享资源作为同步监视器 同步方法中无需指定同步监视器 因为同步方法中的监视器是this 也就是该对象本身 同步监视器的执行过程 第一个线程访问， 锁定同步监视器 执行其中的代码 第二个线程访问 发现同步监视器被锁定 无法访问 第一个线程访问完毕 解锁同步监视器 第二个线程访问 发现同步监视器未锁 锁定并访问 线程通信12345final void wait () 表示线程一直等待 直到其他的线程通知final void wait (long timeout) 线程等待指定毫秒参数的时间final void wait (long timeout,int nanos ) 线程等待指定毫秒、微妙的时间final void notify () 唤醒一个处于等待状态的线程final void notifyAll() 唤醒同一个对象上所有调用wait() 方法的线程，优先级别高的线程优先运行 注意事项：以上的方法只能在同步方法或者同步代码块中使用 否则会抛出异常 死锁：同步可以保证资源共享操作的正确性 但是过多同步也会产生死锁 死锁一般情况下表示互相等待，是程序运行时出现的一种问题 线程的生产者与消费者 生产者不断生产，消费者不断取走生产者生产的产品 生产者生产产品放到一个区域中 之后消费者从此区域里取出产品]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java笔记11]]></title>
    <url>%2F2019%2F05%2F14%2Fjava%E7%AC%94%E8%AE%B011%2F</url>
    <content type="text"><![CDATA[IO流file类File file02 = new File( new URI(“file:文件地址”)); 12345678910111213141516171819202122232425//判断文件或者目录是否存在// System.out.println(file.exists());//判断file对指向的是文件还是目录// System.out.println(file.isFile());// System.out.println(file.isDirectory());//获取文件的相对路径和绝对路径// System.out.println(file.getPath());// System.out.println(file.getAbsolutePath());//获取文件的名字// System.out.println(file.getName());//删除文件// System.out.println(file.delete());//创建文件// System.out.println(file.createNewFile());//获取文件内容的长度// System.out.println(file.length());File file02 = new File(&quot;D://1/123.txt&quot;);//创建路径指向的目录，如果目录不存在 则创建失败System.out.println(file02.mkdir());// 创建路径指定的目录 如果不存在 就创建出来System.out.println(file02.mkdirs());// 判断文件是否存在System.out.println(file02.delete());System.out.println(file02.exists()); 流的基本概念 流是指一连串流动的字符，是以先进先出的方式发送信息的通道 输入/输出流与数据源 XXX–&gt;程序—&gt;输入流 程序—&gt;XXX—&gt;输出流 java流的分类输入和输出是相对于 1.功能不同 节点流：可以直接从数据或目的地读写数据 处理流（包装流）：不直接连接到数据点或目的地，是对其他流进行分装。其目的是简化操作和提高性能。 节点流和处理流的关系 节点流处于io操作的第一线，所有操作必须通过他们进行 处理流可以对其他流进行处理（提高效率或者操作灵活性） 文件的读写 文本文件的读写 用FileInputStream和FileOutputStream读写文本文件 用BUfferedReader和BufferedWriter读写文本文件 二进制文件的读写 使用DataInputStream和DataOutputStream读写二进制文件以及基本数据类型数据的读写 对象的读写 使用ObjectInputStream和ObjectOutputStream读写对象（序列化和反序列化） 使用FileInputStream读文本文件 使用字符流读写文件文件 读文件 使用Reader抽象类实现 写文件 使用Writer抽象类实现 BufferedReader类 BufferedReader类是Reader类是Reader类的子类 BufferedReader类带有缓冲区 按行读取内容的readLine()方法（BufferedReader类特有的方法） 标准的输入输入输出流System.in，System.out Scanner input = new Scanner（System.in）； 没有Scanner如何获取数据？1.5版本产生,目的是方便使用输入流 Scanner 是一个输入流，数据源可以是键盘也可以是文件 1.5之前如何输入数据？ //键盘作为输入流的数据源 1BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); ​ //文件作为输入流的数据源 //创建对象,从文件中获取字节输入流 Scanner input = new Scanner(new File(“D:\a.txt”)); 文本操作: FileReader, FileWriter 字节操作: FileInputStream, FileOutputStream 基本数据类型操作:DataInputStream, DataOutputStream 操作对象: ObjectInputStream ,ObjectOutputStream File 类用于访问文件或目录的属性 程序和数据源之间通过流联系 输入流和输出流 字节流和字符流 节点流和包装流 FileInputStream和FileOutputStream以字节流的方式读写文本文件。 BufferedReader和BufferedWriter以字符流的方式读写文本文件，而且效率更高。 FileInputStream FileOutputStream 字节的输入输出流 FileWriter FileReader 字符的输入输出流 BufferedReader BufferedWriter 带缓冲区的字符输入输出流,可以提高字符输入输出的效率 ObjectInputStream ObjectOutputStream 对象的输入输出流,用于将对象直接写入文件中,直接从文件中读取对象(操作的对象的类必须实现Serializable) InputStreamReader OutputStreamWriter Reader和Writer的编码方式 涉及到的类: 读:FileReader (File file) 写:FileWriter(File file) 加入缓冲区的读:BufferedReader(Reader fr) 加入缓冲区的写:BufferedWriter(Writer bw) 123FileInputStream fis=new FileInputStream(“文件的路径”);InputStreamReader isr=new InputStreamReader(fis,”utf-8”);BufferedReader br=new BufferedReader(isr);]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java笔记10]]></title>
    <url>%2F2019%2F05%2F13%2Fjava%E7%AC%94%E8%AE%B010%2F</url>
    <content type="text"><![CDATA[容器1234567891011121314151617181920212223242526272829303132333435package day13;import java.util.ArrayList;import java.util.Collection;public class CollectionDemo &#123;public static void main(String[] args) &#123;//创建一个Collection 接口的引用，指向一个实现类的对象Collection cln = new ArrayList();//添加一个元素cln.add(&quot;1&quot;);cln.add(&quot;2&quot;);cln.add(&quot;3&quot;);Collection cln2 = new ArrayList();//添加一个元素cln2.add(&quot;1&quot;);cln2.add(&quot;2&quot;);//cln2.add(&quot;3&quot;);//将cln2中所有的元素都拷贝到cln1中//cln.addAll(cln2);//清空容器//cln.clear();//判断当前容器中包不包含某个元素//System.out.println(cln.contains(&quot;5&quot;));//判断当前容器中是否包含cln2这个容器中所有的元素//System.out.println(cln.containsAll(cln2));//判断两个容器是否相等//System.out.println(cln.equals(cln2));//删除某个元素//cln.remove(&quot;1&quot;);//从cln里面删除所有cln2里面包含的元素 从cln里面删除和cln2的交集//cln.removeAll(cln2);//从cln中保留和cln2的交集//cln.retainAll(cln2);System.out.println(cln.size());&#125;&#125; Java集合框架包含的内容：Java集合框架提供了一套性能优良、使用方便的接口和类，它们位于java.util包中 集合作为容器应该具有的功能（增，删，改，查）， 不一定全有。 集合的基本操作：增加，删除，判断，取出。 List与Set接口 Collection 接口存储一组不唯一，无序的对象 List 接口存储一组不唯一，有序（插入顺序）的对象 Set 接口存储一组唯一，无序的对象 123456789101112131415161718192021222324package day13;import java.util.ArrayList;import java.util.List;/**- list接口- 就是在Collection接口上添加了下标- 在List接口中多了一些通过下标来操作元素的方法- @author tang * */ public class ListDemo &#123; public static void main(String[] args) &#123; List list = new ArrayList(); list.add(&quot;1&quot;); list.add(&quot;3&quot;); list.add(&quot;1&quot;); //将元素插入到指定的位置 list.add(1, &quot;2&quot;); //通过下标来获取元素 //System.out.println(list.get(1)); //通过元素来查找下标 //System.out.println(list.indexOf(“2”)); //获取最后一次出现的元素的位置 //System.out.println(list.lastIndexOf(“1”)); //通过下标来删除元素 返回值是所删除的元素的内容 //System.out.println(list.remove(3)); //用指定的元素替换list中指定位置的元素 //list.set(0, “10”); //提取一个子列表 List list02 = list.subList(1, 3); System.out.println(list02); 123 &#125;&#125; ArrayList实现了长度可变的数组，在内存中分配连续的空间。优点：遍历元素和随机访问元素的效率比较高 缺点：添加和删除需要大量移动元素效率低，按照内容查询效率低 123456789101112131415161718192021222324252627package day13;import java.util.ArrayList;import java.util.ListIterator;public class ListIteratorDemo &#123;public static void main(String[] args) &#123;ArrayList list = new ArrayList();list.add(&quot;1&quot;);list.add(&quot;2&quot;);list.add(&quot;3&quot;);list.add(&quot;4&quot;);ListIterator it = list.listIterator();//判断迭代器中有没有下一个元素while (it.hasNext()) &#123;//获取下一个元素的下标System.out.println(&quot;下一个元素的下标是:&quot;+it.nextIndex());//获取下一个元素的值System.out.println(&quot;下一个元素的值是:&quot; + it.next());//将next获取到的那个元素替换为参数的值it.set(&quot;*&quot;);&#125;while (it.hasPrevious()) &#123;System.out.println(&quot;上一个元素的下标是:&quot; + it.previousIndex());System.out.println(&quot;上一个元素的值是:&quot;+it.previous());&#125;System.out.println(list);&#125;&#125; LinkedList采用双向链表存储方式。优点：插入、删除元素时效率比较高 缺点：遍历和随机访问元素效率低下 List接口特有的方法 Iterator 接口 所有实现了Collection接口的容器类都有一个iterator方法用以返回一个实现了Iterator接口的对象。 Iterator对象称作迭代器，用以方便的实现对容器内元素的遍历操作。 Iterator接口定义了如下方法： 123boolean hasNext(); //判断是否有元素没有被遍历Object next(); //返回游标当前位置的元素并将游标移动到下一个位置void remove(); //删除游标左面的元素，在执行完next之后该 12345678910111213141516171819202122232425262728package day13;import java.util.ArrayList;import java.util.Iterator;public class IteratorDemo &#123;public static void main(String[] args) &#123;ArrayList list = new ArrayList();list.add(&quot;1&quot;);list.add(&quot;2&quot;);list.add(&quot;3&quot;);list.add(&quot;4&quot;);//通过方法获取到一个迭代器Iterator it = list.iterator();//判断有没有下一个元素while (it.hasNext()) &#123;//如果循环继续 则说明有下一个元素//并且在当前这次循环中只能使用一次next方法 String str = (String) it.next();System.out.println(str);if (str.equals(&quot;1&quot;)) &#123;//删掉刚才调用next方法获取到的元素it.remove();&#125;&#125;System.out.println(list);&#125;&#125; 所有的集合类均未提供相应的遍历方法，而是把遍历交给迭代器完成。迭代器为集合而生，专门实现集合遍历 可以使用Iterator遍历的本质是什么？ 实现Iterable接口 For-each循环–增强的for循环，遍历array或Collection的时候相当简便 –无需获得集合和数组的长度，无需使用索引访问元素，无需循环条件 –遍历集合时底层调用Iterator完成操作 For-each缺陷–数组： •不能方便的访问下标值 •不要在for-each中尝试对变量赋值，只是一个临时变量 –集合： •与使用Iterator相比，不能方便 的删除集合中的内容 For-each总结–除了简单的遍历并读出其中的内容外，不建议使用增强for ArrayList遍历元素和随机访问元素的效率比较高 插入、删除等操作频繁时性能低下 LinkedList插入、删除元素时效率较高 查找效率较低 遍历效率低 泛型1234567891011121314public interface FanXingInterface &#123;&#125;使用方法1:实现类能明确泛型所指代的具体数据类型public class ImP implements FanXingInterface&#123;public static void main(String[] args) &#123;ImP im = new ImP();&#125;&#125;2：实现类也不知道泛型的具体类型，则在创建对象的时候指定class imp2 implements FanXingInterface&#123;public static void main(String[] args) &#123;imp2 im = new imp2();&#125;&#125; 为什么需要泛型​ 1.因为集合中可以存放任意引用数据类型,所以在使用的时候可能需要向下类型 转型在转型的时候如果不确定元素的类型,很容易出错,所以有时候我们会规定在集合中只能存放一种类型的数据 这就是泛型 泛型的分类 泛型类 泛型方法 1234567891011121314151617public class DataClass &#123;//这个方法的类型E是在调用方法的时候指定public void show(E e)&#123;System.out.println(e);&#125;//这个方法的数据类型,在创建类的对象时指定//泛型方法,解决了参数个数相同情况的方法重载public void fun(T t)&#123;System.out.println(t);&#125;//可变参数的泛型方法//解决参数个数,顺序都不同的方法重载问题public void Method(E...e)&#123;//该方法在调用的时候可以传任意类型的参数,任意个数任意顺序System.out.println(e[1]);&#125;&#125; 泛型接口Set接口中的实现类 Set接口Set接口存储一组唯一，无序的对象 （存入和取出的顺序不一定一致） 操作数据的方法与List类似，Set接口不存在get()方法 HashSet 采用Hashtable哈希表存储结构 优点：添加速度快，查询速度快，删除速度快 缺点：无序 LinkedHashSet 采用哈希表存储结构，同时使用链表维护次序 有序（添加顺序） TreeSet采用二叉树（红黑树）的存储结构 优点：有序（排序后的升序）查询速度比List快 ​ （按照内容查询） 缺点：查询速度没有HashSet快 Hash表 代码验证HashSet的无序性与唯一性 使用HashSet存储自定义对象，重写hashCode方法与equals方法 TreeSet存放自定义类型 使用TreeSet存放自定义类型的对象会报错，原因是自定义的类中没有指定排序的方式 解决方法：自定义的类实现Comparable 接口，实现compareTo方法 Comparable 接口实现了Comparable 接口的类通过实现 comparaTo 方法从而确定该类对象的排序方式。 Map接口 Map特点特点是key-value映射 HashMap:Key无序 唯一（Set) Value 无序 不唯一（Collection） LinkedHashMap特点是有序HashMap TreeMap有序 速度没有hash快 Set与Map有关系吗？ 采用了相同的数据结构，只用于map的key 存储数据 HashMap 和linkedHashMap用的最多的是HashMap,在Map中插入、删除和定位元素，HashMap是最好的选择。如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现 ，他还可以按读取顺序来排列。 HashMap是一个最常用的Map，他可以根据键hashCode值存储数据，根据键可以直接获取他的值，具有很快的访问速度。HashMap最多只允许一条键的记录为null,允许多条值的记录为Null。 HashMap不支持线程同步，即任一时刻可以有多个线程同时写HashMap,可能会导致数据的不一致性，如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力 LinkedHashMap保存了记录的插入顺序，在用Iterator遍历 LinkedHashMap时，先得到的记录肯定是先插入的。 Collections工具类Collections和collection不同，前者是集合的操作类，后者是集合接口 Collections提供的静态方法 addAll(): 批量添加 sort():排序 binarySearch(): 二分查找 fill(): 替换 reverse(): 逆序 集合总结]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML笔记1]]></title>
    <url>%2F2019%2F05%2F10%2FHTML%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[Web三大基石：1、html 显示数据2、http 传输数据3、u r l 定位数据 HTML( Hyper Text Makeup Language):超文本标记语言1、什么是文本: 记录一些文本信息的称为文本。2、什么是纯文本:只记录文字本身，不记录样式的文本叫纯文本。3、什么是超文本:超文本使用链接的方法，将各种不同的空间的而文字信息组织在一起的网状文本。HTML的版本：以后主流的HTML5版本，HTML4版本包括两个小版本HTML4.01和xhtml1.0HTML的本质：使文本具有语义的功能 HTML的语法：1、HTML的注释不能嵌套 2、标签必须正确关闭 3、标签必须成对出现 4、标签不能随意嵌套 5、标签中可以有属性，属性出现在首标签的尖括号内必须和首标签有一个空白字符，属性和属性之间必须有一个空白字符 6、属性必须有值，且值必须被引号引起来（在HTML中单引号和双引号是一个意思）都表示字符串 7、标签必须使用小写字母 8、W3School.com 定义前端规则的一个正规网站 称HTML标签和head是父子关系称head 和 body标签是兄弟关系 12345678910111213141516171819202122232425262728293031&lt;div&gt; 可定义文档中的分区或节（division/section)&lt;h1&gt; 标签是让文本具有一级语义&lt;h2&gt; 标签是让文本具有二级语义&lt;h6&gt; 最高只有六级语义&lt;p&gt; 标签使文本具有段落语义&lt;br/&gt; 换行&lt;hr/&gt; 下划线&lt;b&gt; 粗体字 &lt;i&gt; 斜体字&lt;font color=&quot;&quot;size=&quot;8&quot;&gt;你看我是什么颜色&lt;/font&gt;&amp;nbsp 表示空格&lt;sup&gt; 上标&lt;sub&gt; 下标src 图片的路径alt 当图片显示不了的时候用于提醒的文字title 当鼠标悬停图片时 显示的文字width设置图片的宽height 显示图片的高 【HTML】实现了Web页面。 【URL】1.url Uniform Resource Locator的缩写,称为统一资源定位符。通过URL可以访问到互联网上的一个资源。如：图片、视频、网页等。通过URL可以找到资源。 2.uriUniform Resource Identifier的缩写，称为统一资源标识符。 【HTTP协议】1.概述Hyper Text Transfer Protocol（超文本传输协议）的缩写。 2.作用 保证传输的优先级 保证传输的正确性 保证传输效率 3.工作方式 建立连接 发送请求 响应请求 断开连接 4.特点 请求响应式 无状态 HTTP1.1版之后支持持续连接]]></content>
      <categories>
        <category>HTML（1）</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java笔记9]]></title>
    <url>%2F2019%2F05%2F10%2Fjava%E7%AC%94%E8%AE%B09%2F</url>
    <content type="text"><![CDATA[String Buffer类 123456789101112131415•将一个数字字符串转换成逗号分隔的数字串，即从右边开始每三个数字用逗号分隔•利用StringBuffer类的length()和insert ()方法实现需求public class TestInsert &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in);System.out.print(&quot;请输入一串数字： &quot;);String nums = input.next();StringBuffer str=new StringBuffer(nums);for(int i=str.length()-3;i&gt;0;i=i-3)&#123;str.insert(i,&apos;,&apos;);&#125;System.out.print(str);&#125;&#125; String：不可变字符序列 String Builder：可变字符序列、效率高、线程不安全 String Buffer：可变字符序列、效率低、线程安全 Math类包含了常见的数学运算函数。 random()生成[0,1)之间的随机浮点数 生成：0-10之间的任意整数： int a = (int)(10*Math.random()); 生成：20-30之间的任意整数： int b = 20 + (int)(10*Math.random()); # 枚举枚举类型： 只能够取特定值中的一个 使用enum关键字 所有的枚举类型隐性地继承自 java.lang.Enum。（枚举实质上还是类！而每个被枚举的成员实质就是一个枚举类型的实例，他们默认都是public static final的。可以直接通过枚举类型名直接使用它们。） 强烈建议当你需要定义一组常量时，使用枚举类型 异常机制异常是指在程序的运行过程中所发生的不正常的事件，它会中断正在运行的程序 Java编程语言使用异常处理机制为程序提供了错误处理的能力 Java中如何进行异常处理 Java的异常处理是通过5个关键字来实现的：try、catch、 finally、throw、throws ` 12345678910111213141516171819202122232425262728293031public void method()&#123;``try &#123;``// 代码段(此处不会产生异常)``&#125; catch (异常类型 ex) &#123;``// 对异常进行处理的代码段``&#125;``// 代码段``&#125;``•使用try-catch块捕获异常，分为三种情况：``第二种情况：出现异常``public void method()&#123;``try &#123;``// 代码段 1``// 产生异常的代码段 2``// 代码段 3``&#125; catch (异常类型 ex) &#123;``// 对异常进行处理的代码段4``&#125;``// 代码段5``&#125;``第三种情况：异常类型不匹配``public void method()&#123;``try &#123;``// 代码段 1``// 产生异常的代码段 2``// 代码段 3``&#125; catch (异常类型 ex) &#123;``// 对异常进行处理的代码段4``&#125;``// 代码段5``&#125; 常见的异常类型 在try-catch块后加入finally块 是否发生异常都执行 不执行的唯一情况: 1.中止当前虚拟机：System.exit() Java语言中通过throws声明某个方法可能抛出的各种异常 可以同时声明多个异常，由逗号隔开 异常分为Checked异常和运行时异常 Checked异常必须捕获或者声明抛出 运行时异常不要求必须捕获或者声明抛出 try-catch-finally中存在return语句的执行顺序: 1.不管有木有出现异常，finally块中代码都会执行； 2、当try和catch中有return时，finally仍然会执行； 3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样， 返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的； 4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。 throw和throws关键字的区别： 1.throws出现在方法函数头；而throw出现在函数体。2.throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。 3.两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 笔记8]]></title>
    <url>%2F2019%2F05%2F05%2Fjava-%E7%AC%94%E8%AE%B08%2F</url>
    <content type="text"><![CDATA[内部类将一个类定义置入另一个类定义中就叫作“内部类” 类中定义的内部类特点 内部类作为外部类的成员，可以直接访问外部类的成员（包括private成员），反之则不行。 内部类做为外部类成员，可声明为private、默认、protected或public。 内部类成员只有在内部类的范围之内是有效的。 用内部类定义在外部类中不可访问的属性。这样就在外部类中实现了比外部类的private还要小的访问权限。 编译后生成两个类： 1OuterClass.class 和OuterClass$InnerClass.class 列子： 123456789101112131415public class WaiBuLei &#123; //外部类class InnerClass&#123;//内部类public void show()&#123;//内部类中的方法&#125;&#125;public void print() &#123;//外部类的方法可以创建内部类的对象，来调用内部类的方法innerClass i = new innerClass();i.show();&#125;&#125;其他类不能直接访问内部类，只能间接方法，创建外部类的对象，再创建内部类的对象,才能使用内部类WaiBuLei n = new WaiBuLei();innerClass = n.new nnerClass(); 如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量需要使用this关键字. 内部类分类成员内部类 静态内部类 方法内部类 匿名内部类 package 成员内部类;import 成员内部类.OuterClass.InnnerClass;public class Test {public static void main(String[] args) {OuterClass oc = new OuterClass();oc.test();//用一个外部类的对象来创建内部类的对象InnnerClass ic = oc.new InnnerClass();ic.test01();}} 12 12345678910111213141516171819202122232425package 成员内部类;//外部类public class OuterClass &#123;//在这里定义外部类的成员//外部类的成员变量private String name = &quot;张三&quot;; //在这里定义的类 就是成员内部类class InnnerClass&#123;//内部类的成员变量private String name = &quot;李四&quot;;//内部类的成员方法public void test01() &#123;//当内部类的成员 和外部类的成员重名的时候 在内部类默认使用内部类的成员//如果在内部类想要使用外部类的重名成员 需要用 外部类名.this.成员名System.out.println(&quot;内部类的成员方法&quot;+OuterClass.this.name);&#125; &#125;//外部类的成员方法public void test() &#123;System.out.println(&quot;外部类的成员方法&quot;);//外部类的成员方法可以直接使用内部类InnnerClass ic = new InnnerClass();ic.test01();&#125;&#125; 123456789101112131415161718•在内部类前加static 就是静态内部类、如果内部类中的属性或方法是static，则这个内部类必须是static//定义静态内部类public class StaticOuterClass &#123;static private String info = &quot;hello&quot;;static class InnerClass&#123;public void show() &#123;//静态内部类只能使用外部类的静态属性 System.out.println(info);&#125;&#125; &#125;public class Test &#123;public static void main(String[] args) &#123;//new 的是内部类的对象• StaticOuterClass.InnerClass in = new StaticOuterClass.InnerClass();in.show();&#125;&#125; 静态内部类只能使用外部类的静态属性或方法 123456789package 静态内部类;public class Test &#123;public static void main(String[] args) &#123;//静态的内容都是属于类所有，可以通过类名直接调用//所以静态的内部类也是属于类所有，可以直接用外部类的类名来调用 来创建对象OuterClass.InnerClass ic = new OuterClass.InnerClass();ic.test();&#125;&#125; 1234567891011121314151617package 静态内部类;/**- 当内部类中有静态的成员的时候，内部类就必须声明为静态内部类- @author tang * */ public class OuterClass &#123; static String name = &quot;张三&quot;; static class InnerClass&#123; //静态内部类只能使用外部类的静态成员 //不能使用外部类的非静态成员 public void test() &#123; System.out.println(name); &#125; &#125; &#125; 匿名内部类没有名字的内部类 匿名内部类有个前提条件：必须存在继承和实现关系 适合只需要使用一次的类 普通内部类 匿名内部类 创建接口或抽象类的对象，写一对{ ​ //实现接口或者抽象类的抽象方法 }.实现的方法名（）; package 匿名内部类;public class Test {public static void main(String[] args) {//当一个接口的实现类只需要使用一次，这时候可以直接用接口来new对象//接口不能直接创建对象，所以在new对象之前 先将接口实现成一个实现类 再用该实现类去创建对象MyInterface mi = new MyInterface() {@Overridepublic void test() {System.out.println(“内部类的方法”);}};mi.test();}} 12 123456package 匿名内部类;public interface MyInterface &#123;void test();&#125; 12345678910111213141516171819202122232425package 方法中的内部类;//方法中的内部类public class OuterClass &#123;//外部类的成员变量private String name;//外部类的成员方法public void test() &#123;//方法中的内部类 //方法中的内部类 只能在方法内使用，出了方法就不能再使用方法中的内部类了class InnerClass&#123;//内部类的成员变量private String name;//内部类的成员方法public void test() &#123;System.out.println(&quot;内部类的方法&quot;);&#125;&#125;//方法中的内部类 只能在方法内使用，出了方法就不能再使用方法中的内部类了//所以要想使用内部类 就必须在方法结束之前使用内部来创建一个对象 使用内部类的对象来调用内部类的方法new InnerClass().test();&#125;//外部类的方法public void test02() &#123;&#125;&#125; 1234567package 方法中的内部类;public class Test &#123;public static void main(String[] args) &#123;OuterClass oc = new OuterClass();oc.test();&#125;&#125; 垃圾回收机制 对象空间的分配： 使用new关键字创建对象即可 对象空间的释放： 传统的C/C++语言，需要程序员负责回收已经分配内存。显式回收垃圾回收的缺点： 程序忘记及时回收，从而导致内存泄露，降低系统性能。 程序错误回收程序核心类库的内存，导致系统崩溃。 Java语言不需要程序员直接控制内存回收，是由JRE在后台自动回收不再使用的内存，称为垃圾回收机制(Garbage Collection)。 可以提高编程效率。 保护程序的完整性。 其开销影响性能。Java虚拟机必须跟踪程序中有用的对象，确定哪些是无用的。 垃圾回收机制只回收JVM堆内存里的对象空间。 对其他物理连接，比如数据库连接、输入流输出流、Socket连接无能为力 现在的JVM有多种垃圾回收实现算法，表现各异。 垃圾回收发生具有不可预知性，程序无法精确控制垃圾回收机制执行。 可以将对象的引用变量设置为null，暗示垃圾回收机制可以回收该对象。 程序员可以通过System.gc()或者Runtime.getRuntime().gc()来通知系统进行垃圾回收，会有一些效果，但是系统是否进行垃圾回收依然不确定。 垃圾回收机制回收任何对象之前，总会先调用它的finalize方法（如果覆盖该方法，让一个新的引用变量重新引用该对象，则会重新激活对象）。 永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用 JAVA常用类•基本数据类型的包装类 •字符串相关类 u不可变字符序列：String u可变字符序列：StringBuffer、StringBuilder •Math类 •File类 •枚举类 包装类是将基本类型封装到一个类中 包含属性和方法，方便对象操作 包装类位于java.lang包中 包装类和基本类型1234基本数据类型转换为包装类Integer intValue = new Integer(21);或Integer intValue = new Integer(&quot;21&quot;);Integer intValue = Integer.valueOf(&quot;21&quot;); 12345包装类转换成基本类型Integer integerId=new Integer(25);int intId=integerId.intValue(); 1234基本类型和包装类的自动转换Integer intObject = 5;int intValue = intObject包装类并不是用来取代基本类型的 自动装箱和自动拆箱 A(auto-boxing &amp; unboxing)自动装箱 基本类型就自动地封装到与它相同类型的包装中，如： Integer i = 100; 本质上是，编译器编译时为我们添加了： Integer i = Integer.valueOf(100 自动拆箱 包装类对象自动转换成基本类型数据。如： int a = new Integer(100); 本质上，编译器编译时为我们添加了： int a = new Integer(100).intValue(); 123456789101112131415161、装箱 与拆箱装箱: 基本 --&gt;类new Integer(int)Integer.valueOf(int i) ;拆箱: 类 --&gt;基本intValue()2、方法1)、与字符串转换的方法a)、字符串 --&gt;IntegerInteger(String s)Integer.parseInt(String s)Integer.valueOf(String s);b)、Integer --&gt;字符串toString()String.valueOf(Object obj) ;Integer --&gt;int +&quot;&quot; 12345678910111213141516171819202122232425262728293031package 基本数据类型的包装类;public class Test &#123;public static void main(String[] args) &#123;String str = &quot;123456&quot;;// int sum = 0;// for (int i = 0; i &lt; str.length(); i++) &#123;// char c = str.charAt(i);// int c1 = (c-48);// c1 *= Math.pow(10, str.length()-1-i);// sum += c1;// &#125;// // System.out.println(sum+1);Integer ig = new Integer(str);ig = Integer.valueOf(str,16);int i = ig.intValue();System.out.println(i);//用指定的进制来将表示数字的字符串转换为数字int a = Integer.parseInt(&quot;123&quot;,16);//将一个数字转为指定进制的数字str = Integer.toBinaryString(10);str = Integer.toHexString(123);//把数字转换为字符串str = Integer.toString(123,16);System.out.println(str);//自动装箱 就是自动将int类型的变量 封装成了一个Integer类型的对象Integer ig2 = 123;//自动拆箱 ，自动将Integer类型的对象中包含的int类型的变量读出来int b = ig2;&#125;&#125; String类位于java.lang包中，具有丰富的方法 计算字符串的长度、比较字符串、连接字符串、提取字符串 Java字符串就是Unicode字符序列，例如串“Java”就是4个Unicode字符J,a,v,a组成的。 123Java允许使用符号&quot;+&quot;把两个字符串连接起来String s1 = “Hello”;String s2 = “World!”;String s = s1 + s2; //HelloWorld! 12345678910111213141516171819202122232425262728&#125;char charAt(int index)◦返回字符串中第index个字符。&#125;boolean equals(String other)◦如果字符串与other相等，返回true&#125;boolean equalsIgnoreCase(String other)◦如果字符串与other相等（忽略大小写），则返回true&#125;int indexOf(String str) lastIndexOf(String str,int idx)&#125;int length()◦返回字符串的长度。&#125;String replace(char oldChar,char newChar)◦返回一个新串，它是通过用 newChar 替换此字符串中出现的所有oldChar而生成的◦◦代码：StringTest1.java&#125;boolean startsWith(String prefix)◦ 如果字符串以prefix开始，则返回true&#125;boolean endsWith(String prefix) ◦如果字符串以prefix结尾，则返回true&#125;String substring(int beginIndex)&#125;String substring(int beginIndex,int endIndex)◦返回一个新字符串，该串包含从原始字符串beginIndex到串尾或endIndex-1的所有字符&#125;String toLowerCase()◦返回一个新字符串，该串将原始字符串中的所有大写字母改成小写字母&#125;String toUpperCase()◦返回一个新字符串，该串将原始字符串中的所有小写字母改成大写字母&#125;String trim()◦返回一个新字符串，该串删除了原始字符串头部和尾部的空格◦◦代码：StringTest2.java 字符串12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package 字符串;import java.io.UnsupportedEncodingException;import java.util.Arrays;/**- 字符串常用方法- @author tang * */ public class StringDemo02 &#123; public static void main(String[] args) throws UnsupportedEncodingException &#123; String str = &quot;abcdefga&quot;; String str02 = new String(&quot;abcdefg&quot;); //通过下标来获取字符串中指定的字符 //System.out.println(str.charAt(4)); //字符串类中重写了equals方法，重新制定了判断相等的规则为字符串的内容是否相等 //System.out.println(str == str02); //System.out.println(str.equals(str02)); //忽略大小写进行比较 //System.out.println(str.equalsIgnoreCase(str02)); //字符串的查找 查找第一次出现的下标 //System.out.println(str.indexOf(97)); //查找最后一次出现的位置 //System.out.println(str.lastIndexOf(&quot;a&quot;)); //获取字符串的长度 //System.out.println(str.length()); //字符串的替换 //String str03 = str.replace(&quot;a&quot;, &quot;*&quot;); //判断字符串的前缀 //System.out.println(str.startsWith(&quot;abcdfga&quot;)); //判断字符串的后缀 //System.out.println(str.endsWith(&quot;abcdefga&quot;)); //字符串的提取从指定的位置开始 提取到字符串结束 //System.out.println(str.substring(3)); //字符串的提取 从指定的位置提取到指定的位置 包含开始的位置 不包含结束的位置 //System.out.println(str.substring(1, 5)); //大小写转换 //System.out.println(str.toUpperCase()); //去处前后的空格 //System.out.println(str.trim()); //字符串比较大小 //str = &quot;abh&quot;; //int i = str.compareTo(&quot;ade&quot;); //System.out.println(i); //字符串的链接 //String str03 = str.concat(&quot;123&quot;); //判断字符串中是否包含指定字符串 //boolean b = str.contains(&quot;abc&quot;); //按照指定的编码格式 将字符串拆分成字节数组 // str = &quot;你好&quot;; // byte [] bs = str.getBytes(&quot;UTF-8&quot;); // System.out.println(new String(bs,&quot;UTF-8&quot;)); //字符串的剪切 str = &quot;hello i am teacher ma &quot;; String [] strs = str.split(&quot; &quot;); System.out.println(Arrays.toString(strs)); &#125; &#125; 1234567891011121314151617181920package 字符串;import java.nio.charset.Charset;public class StringDemo &#123;public static void main(String[] args) &#123;//使用双引号标记出来的字符串是保存在共享区，//当已经有一个相同内容的字符串的时候，代码中再标记一个字符串，系统就不会再去共享区创建一个新的对象//而是直接返回已有的字符串对象的地址String str = &quot;abc&quot;;String str02 = new String(&quot;abc&quot;);String str03 = &quot;abc&quot;;System.out.println(str == str03);//字符串的创建str = new String();str = new String(&quot;abc&quot;);//通过一个byte类型的数组来创建一个字符串str = new String(new byte[]&#123;97,98,99,100&#125;,1,3);str = new String(new char[]&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;);System.out.println(str); &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java script数组代码]]></title>
    <url>%2F2019%2F04%2F29%2Fjava-script%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[java script 数组代码笔记123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//一、创建数组 //1.创建空数组 var arr = new Array(); console.log(arr.length); //2.创建具有长度的数组 var arr2 = new Array(10); console.log(arr2) //3.创建一个带元素的数组 var arr3 = new Array(123, true, &quot;hello&quot;, new Date()); //4.创建一个带元素的数组2 var arr4 = [123]; console.log(arr4.length)​ //二、属性​ // length属性：表示数组的长度​ console.log(arr3);​ arr3.length = 0; //清空数组​ console.log(arr3);​ arr3.length = 4;​ console.log(arr3​ //三、方法​ var arrdemo = new Array(123, true, &quot;hello&quot;, new Date(), 444333);​ //join():指定一个字符，用该字符连接数组的每一个元素，并作为一个字符串返回​ var result = arrdemo.join(&quot;-&quot;);​ console.log(result);​ //push():向数组的末尾添加一个元素，返回数组的新长度​ result = arrdemo.push(&quot;world&quot;);​ console.log(result)​ console.log(arrdemo);​ //pop():从数组末尾取出一个元素，并返回该元素本身​ result = arrdemo.pop();​ console.log(result);​ console.log(arrdemo);​ //shift()：从数组头部取出一个元素，并返回该元素本身​ result = arrdemo.shift();​ console.log(result);​ console.log(arrdemo);​ //unshift()：向数组的头部添加一个元素，返回数组的新长度​ result = arrdemo.unshift(&quot;bbb&quot;);​ console.log(result);​ console.log(arrdemo);​ //concat()：拼接数组，并作为一个新的数组返回​ var a1 = [123, 234];​ var a2 = [&quot;aaa&quot;, &quot;bbb&quot;];​ var a3 = [new Date()];​ var newarr = a1.concat(a2, a3);​ console.log(newarr);​ //reverse():反转数组​ newarr.reverse();​ console.log(newarr);​ //sort():自然顺序​ // var sortarr = [4534,22,66,88,123];​ var sortarr = [4534, 22, 66, 88, 123, &quot;A&quot;, &quot;a&quot;, &quot;ab&quot;, &quot;ba&quot;, &quot;abc&quot;, &quot;bac&quot;];​ sortarr.sort()​ console.log(sortarr);​ //splice()：删除指定位置，指定长度的元素，并在该位置添加新的元素​ var s1 = [&quot;aa&quot;, &apos;kjsdhf&apos;, &apos;123&apos;, 123, 123, 444, 555, 666];​ s1.splice(0,0,&quot;laowang&quot;);​ console.log(s1);​ //slice()；截取子数组​ var s2 = s1.slice(3,5);​ console.log(s2);]]></content>
      <categories>
        <category>java script</category>
      </categories>
      <tags>
        <tag>java script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 笔记7]]></title>
    <url>%2F2019%2F04%2F29%2Fjava%E7%AC%94%E8%AE%B07%2F</url>
    <content type="text"><![CDATA[多态就是程序的最终状态只有在执行过程中才被决定而非在编译期间就决定了。 java中如何实现多态?使用多态的好处? 引用变量的两种类型： 编译时类型（模糊一点，一般是一个父类） public void (Pet pet); 由声明时的类型决定。 运行时类型（运行时，具体是哪个子类就是哪个子类） 由实际对应的对象类型决定。 多态的存在要有3个必要条件： ​ 要有继承，要有方法重写，父类引用指向子类对象 方法的调用看引用,方法的执行看对象作用: 多态 提高了程序的可扩展性和可维护性提高代码复用性 封装 安全 提高代码复用性 继承 提高代码复用性 实现多态的步骤 编写父类 编写子类 子类重写父类方法 运行时,使用父类的类型,子类的对象 引用数据类型的类型转换子类转换为父类：自动转换 上转型对象不能操作子类新增的成员变量和方法。 上转型对象可以操作子类继承或重写的成员变量和方法 如果子类重写了父类的某个方法，上转型对象调用该方法时，是调用的重写方法。 父类转换为子类：强制转换 （绝不是做手术，而是父类的真面目就是一个子类，否则会出现类型转换错误） 为了防止转换出错可以先用 1instanceof 判断类型,再去转换 接口 interface 为什么需要接口?接口和抽象类的区别? 接口就是比“抽象类”还“抽象”的“抽象类”，可以更加规范的对子类进行约束。全面地专业地实现了：规范和具体实现的分离。 接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。如果你好人，则必须干掉坏人；如果你是坏人，则必须欺负好人。 接口的本质是契约，就像我们人类的法律一样。制定好后大家都遵守 项目的具体需求是多变的，我们必须以不变应万变才能从容开发，此处的“不变”就是“规范”。因此，我们开发项目往往都是面向接口编程！ 接口不是类,接口是一种引用数据类型 接口中的属性都必须是public static final ,声明的时候可以省略 但是接口中的成员变量必须在声明的时候就进行初始化 接口中的方法全都是 public abstract 的方法, public abstract可以省略不写 接口不能被实例化 实现类必须实现接口的所有方法 类可以实现多个接口 接口中不可以有构造方法 接口相关规则： 接口中所有方法都是抽象的。 即使没有显式的将接口中的成员用public标示，也是public访问类型的 接口中变量默认用 public static final标示，所以接口中定义的变量就是全局静态常量。 可以定义一个新接口，用extends去继承一个已有的接口 接口不能继承普通类 可以定义一个类，用implements去实现一个接口中所有方法。 可以定义一个抽象类，用implements去实现一个接口中部分方法。 如何定义接口?格式： [访问修饰符] interface 接口名 [extends 父接口1，父接口2…] { 常量定义 //总是public static final 方法定义 //总是：public abstract } 如何实现接口子类通过implements来实现接口中的规范 接口不能创建实例，但是可用于声明引用变量类型。 一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是public的。 Java的类只支持单继承，接口支持多继承 123456789101112131415161718192021222324252627package interfacedemo;/**- 1，接口可以继承其他的接口,接口支持多继承- 2，一个类用implements 关键字去实现一个接口，一个类可以实现多个接口- 3，一个普通的类实现接口，则必须将接口中的所有抽象方法都实现- 4，一个抽象类实现接口，可以不实现接口中的抽象方法- @author tang */ public interface MyInterface&#123; //接口中可以定义成员变量，接口中的所有成员变量默认都是用public static final 修饰 String name = &quot;wangcai&quot;; //接口中所有的方法都是默认用public abstract 来修饰的 public abstract void test01(); public abstract void test02(); &#125; ckage interfacedemo; public class Person implements MyInterface&#123; @Override public void test01() &#123; System.out.println(&quot;test01&quot;); &#125; @Override public void test02() &#123; System.out.println(&quot;test02&quot;); &#125; &#125; C++支持多重继承，Java支持单重继承 C++多重继承的危险性在于一个类可能继承了同一个方法的不同实现，会导致系统崩溃。 Java中，一个类只能继承一个类，但同时可以实现多个接口，既可以实现多重继承的效果和功能，也避免的多重继承的危险性。 123class Student extents Person implements Runner，Flyer&#123;…&#125; 注意：extends 必须位于implements之前]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 笔记6]]></title>
    <url>%2F2019%2F04%2F29%2Fjava%E7%AC%94%E8%AE%B06%2F</url>
    <content type="text"><![CDATA[继承 类是对对象的抽象，继承是对某一批类的抽象，从而实现对现实世界更好的建模。 提高代码的复用性！ extends的意思是“扩展”。子类是父类的扩展 父类：超类、基类、 子类：派生类 小结： 继承的作用：通过继承可以简化类的定义，实现代码的重用 子类继承父类的成员变量和成员方法，但不继承父类的构造方法 –java中只有单继承 ，没有像c++那样的多继承。多继承会引起混乱，使得继承链过于复杂，系统难于维护。就像我们现实中，如果你有多个父母亲，那是一个多么混乱的世界啊。多继承，就是为了实现代码的复用性，却引入了复杂性，使得系统类之间的关系混乱。 –java中的多继承，可以通过接口来实现 –如果定义一个类时，没有调用extends，则它的父类是： 12&gt; java.lang.Objec&gt; 子类可以继承父类的所有资源吗？ 不能，不能被继承的父类成员有 1、private成员 2、子类和父类不再同包，使用默认访问权限的成员 3、构造方法 12345678910111213141516package finaldemo;/**- 1,用final来修饰一个变量， 则该变量就变成了一个常量- 2,用final来修饰一个类，则该类就不能被作为父类继承- 3,用final来修饰一个方法，则该方法就不能被重写- @author tang * */ public class Test &#123; public static void main(String[] args) &#123; final int AGE; AGE = 10; &#125; &#125; 方法的重写（override）在子类中可以根据需要对从基类中继承来的方法进行重写。 重写方法必须和被重写方法具有相同方法名称、参数列表和返回类型。 重写方法不能使用比被重写方法更严格的访问权限。（由于多态） 为什么需要重写父类的方法?父类实现的方法不符合子类的逻辑 父类已经实现了80%,但是子类又必须要使用剩下的20%,所以可以重写父类方法,在方法内用super关键字调用父类的方法,再去完成剩下的20%工作 super关键字定义：super是直接父类对象的引用。 用法：可以通过super来访问父类中被子类覆盖的方法或属性。 普通方法： 没有顺序限制。可以随便调用。 构造函数中： 任何类的构造函数中，若是构造函数的第一行代码没有显式的调用super(…);那么Java默认都会调用super();作为父类的初始化函数。 所以你这里的super();加不加都无所谓。 final关键字定义：final可以用来修饰变量，方法，类。 修饰变量 变量一旦被初始化便不可改变 相当于定义了一个常量 ​ 2.修饰引用数据类型 引用不能被赋值 但属性可以被赋值 ​ 3.修饰方法 final方法是在子类中不能被覆盖的方法 ​ 4.修饰类 final类是无法被任何类继承的 Object类object类是所有java类的根基 如果在类的声明中未使用extends关键字指明其基类，则默认基类为object类 重写：1toString 方法： 默认返回：包名+类名+@+哈希码 可以重写！ 抽象类定义：是一种模版模式。抽象类为所有子类提供了一个通用模版，子类可以在这个模版基础上进行扩展。 作用： 通过抽象类，可以避免子类设计的随意性。通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。 1234567891011121314151617181920212223242526272829303132333435363738394041package 抽象类;/**- class 前加abstract 该类就成为了一个抽象类- 1，抽象类不能创建对象- 2，抽象类一般是一个父类，该父类没有什么存在的意义，就是用来被子类继承 - 3，抽象类中可以有抽象方法，也可以有非抽象方法- 4，一个类继承了一个抽象类，则该类必须要实现该抽象类中的所有抽象方法- 5，如果子类也是抽象类，则可以不实现父类的抽象方法- 6，抽象方法必须定义在抽象类中- 为什么要使用抽象类- @author tang * */ public abstract class Pet &#123; private String name; //抽象方法 //如果一个方法 每个子类实现的逻辑都不一样 则把该方法定义成抽象方法， //让每个子类去根据自己的逻辑实现该方法 public abstract void bark(); public abstract void eat(); public abstract void sleep(); public abstract void play(); //如果一个方法，每个子类实现的逻辑都一样 则该方法直接在父类中实现，子类直接调用 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package 抽象类;public class Dog extends Pet&#123;public void bark() &#123; System.out.println(&quot;won won won...&quot;);&#125;public void eat() &#123; System.out.println(&quot;狗喜欢吃骨头&quot;);&#125;public void sleep() &#123; System.out.println(&quot;狗在睡觉。。。&quot;);&#125;public void play() &#123; System.out.println(&quot;狗在玩飞盘。。。&quot;);&#125;&#125;package 抽象类;public class Cat extends Pet&#123;public void bark() &#123; System.out.println(&quot;maio miao ...&quot;);&#125;public void eat() &#123; System.out.println(&quot;猫在吃鱼。。。&quot;); &#125;public void sleep() &#123; System.out.println(&quot;猫在晒太阳。。。&quot;);&#125;public void play() &#123; System.out.println(&quot;猫在玩老鼠。。。&quot;);&#125;&#125; 总结： 抽象方法和抽象类均必须用abstract来修饰。 抽象方法没有方法体，只需要声明不需实现。 有抽象方法的类只能定义能抽象类 相反抽象类里面的方法不一定全是抽象方法，也可能没有抽象方法。 抽象类可以包含属性、方法、构造方法。 抽象类不能实例化，及不能用new来实例化抽象类，只能用来被子类调用。 抽象类只能用来继承。 抽象方法必须被子类实现。抽象类的子类必须覆盖所有的抽象方法才能被实例化，否则还是抽象类 构造方法调用顺序： 根据super的说明，构造方法第一句 总是：super(…)来调用父类对应的构造方法。 先向上追溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止 对象的比较==和equals() ==： 比较两基本类型变量的值是否相等 比较两个引用类型的值即内存地址是否相等，即是否指向同一对象 equals() ： 两对象的内容是否一致 自定义类须重写equals()，否则其对象比较结果总是false。 123456789101112131415161718192021222324252627package equalsdemo;/**- 判断相等的两种方式 * *1， == - 用来判断基本数据类型的数据是否相等- 也可以用来判断引用数据类型 判断两个引用是否相等 当且仅当两个引用指向的是同一个对象 == 判断才返回true- - *2，equals - 判断引用数据类型的对象是否相等- 如果一个类没有重写该方法，则自动调用到Object中的equals 判断规则跟 == 一样- 如果要自定义判断相等的规则，则在本类中重写equals 方法，在方法内定义比较规则- @author tang * */ public class Test &#123; public static void main(String[] args) &#123; String str01 = &quot;abc&quot;; String str02 = new String(&quot;abc&quot;); System.out.println(str01 == str02); System.out.println(str01.equals(str02)); &#125; &#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 笔记5]]></title>
    <url>%2F2019%2F04%2F26%2Fjava%E7%AC%94%E8%AE%B05%2F</url>
    <content type="text"><![CDATA[面向对象区别： 面向过程：事物比较简单，可以用线性的思维去解决 面向对象：事物比较复杂，使用简单的线性思维无法解决 共同点： 面向过程和面向对象都是解决实际问题的一种思维方式 二者相辅相成，通过面向对象方式方便于我们从宏观上把握事物之间复杂的关系，方便我们分析整个系统，具体到微观操作，仍然使用面向过程方式来处理。 类可以生成对象 类是对象的抽象 对象：是具体的事物 类：是对对象的抽象（抽象 抽出像的部分） 先有具体对象，然后抽象各个对象象的部分，归纳出类通过类在认识其他对象 1、静态的描述声明为类的成员变量 成员变量描述对象有什么 2、动态的描述声明为成员方法 成员方法描述对象可以做什么 3、成员方法可以直接使用成员变量 123456789101112131415161718public class Person &#123;//静态的特征描述为类的成员变量 成员变量描述对象有什么//在这里声明类的成员变量//类的里面 方法的外面String name;int age;String gender;//动态的特征描述为类的成员方法 成员方法描述对象可以做什么public void eat() &#123;//成员方法可以直接使用成员变量System.out.println(name + &quot;在吃饭&quot;);&#125;public void sleep() &#123;System.out.print(name + &quot;在睡觉&quot;);&#125;public void coding() &#123;System.out.print(name + &quot;在敲代码&quot;);&#125;&#125; 类：class 对象：object instance(实例）某个类的对象 &lt;==&gt; 某个类的实例 定义类（类的组成） 属性 field 方法 method 构造方法 construtor 其他：代码块 静态代码块 内部类 类的属性：在定义成员变量时可以对其初始化 如果不对其初始化，Java使用默认的值对其初始化。 创建对象 类名 对象名 = new 类名(); Person p1=new Person(); 调用类的属性和方法 对象名.成员变量 对象名.成员方法 属性 field，或者叫成员变量 属性用于定义该类或该类对象包含的数据或者说静态属性。 属性作用范围是整个类体 内存分析 形参和实参定义方法的参数是形式参数 调用方法的参数是实在参数 调用方法时要求参数个数相同，类型兼容 参数传递 基本数据类型的参数传递 引用数据类型的参数传递 类和类之间的通信 通过创建对象，类和类就建立了联系，通过方法的调用来进行信息的传递 this关键字this的作用: this表示的是当前对象本身， 更准确地说，this代表当前对象的一个引用。 普通方法中使用this。 区分类成员属性和方法的形参. 调用当前对象的其他方法（可以省略） 位置：任意 构造方法中使用this。 使用this来调用其它构造方法 位置：必须是第一条语句 this不能用于static方法。 1234567891011121314151617181920212223242526272829303132333435363738package thisDemo;/** * this 是当前对象的引用 * 哪个对象调用了当前方法 哪个对象就是当前对象 * @author Administrator * */public class Dog &#123; String name; int age; public void test() &#123; System.out.println(this); this.test(); &#125; public void test02() &#123; System.out.println(this); this.test02(); &#125;&#125;package thisDemo;public class Test &#123; public static void main(String[] args) &#123; Dog wangcai = new Dog(); System.out.println(wangcai); wangcai.test(); Dog dahuang =new Dog(); System.out.println(dahuang); dahuang.test(); &#125;&#125; static 关键字在类中，用static声明的成员变量为静态成员变量 ,或者叫做： 类属性，类变量. 它为该类的公用变量，属于类，被该类的所有实例共享，在类被载入时被显式初始化， 对于该类的所有对象来说，static成员变量只有一份。被该类的所有对象共享！！ 可以使用”对象.类属性”来调用。不过，一般都是用“类名.类属性” static变量置于方法区中！ 用static声明的方法为静态方法 不需要对象，就可以调用(类名.方法名) 在调用该方法时，不会将对象的引用传递给它，所以在static方法中不可访问非static的成员。 静态方法不能以任何方式引用this和super关键字 静态初始化块 如果希望加载后，对整个类进行某些初始化操作，可以使用static初始化块。 类第一次被载入时先执行static代码块；类多次载入时，static代码块只执行一次；Static经常用来进行static变量的初始化。 是在类初始化时执行，不是在创建对象时执行。 静态初始化块中不能访问非static成员。 pakage 作用： 为了解决类之间的重名问题。 为了便于管理类：合适的类位于合适的包 用法： 通常是类的第一句非注释性语句。 包名：域名倒着写即可，再加上模块名，并与内部管理类。 注意事项： 写项目时都要加包，不要使用默认包。 com.gao和com.gao.car，这两个包没有包含关系，是两个完全独立的包。只是逻辑上看起来后者是前者的一部分。 JDK中的主要包java.lang 包含一些Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能。 java.awt 包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。 java.net 包含执行与网络相关的操作的类。 java.io 包含能提供多种输入/输出功能的类。 java.util 包含一些实用工具类，如定义系统特性、使用与日期日历相关的函数。 Import 作用：如果不适用import，我们如果用到其他包的类时，只能这么写：java.util.Date，代码量太大，不利于编写和维护。通过import可以导入其他包下面的类，从而可以在本类中直接通过类名来调用。 用法： import java.util.Date; import java.util.*; //导入该包下所有的类。会降低编译速度，但不会降低运行速度。 注意要点： java会默认导入java.lang包下所有的类，因此这些类我们可以直接使用。 如果导入两个同名的类，只能用包名+类名来显示调用相关类： 1java.util.Date date = new java.util.Date(); import static 12–import static java.lang.Math.*;//导入Math类的所有静态属性–import static java.lang.Math.PI;//导入Math类的PI属性 1–然后，我们可以在程序中直接使用：System.out.println(PI); 方法调用中的参数传递（重中之重） 基本数据类型的参数传递：不能改变参数的值 引用数据类型的参数传递：不能改变参数的值 This修饰构造方法（必须是第一条语句） This代表当前对象自身的引用（必须new） This可以修饰属性，区别成员变量和局部变量 This修饰方法 This修饰构造方法（必须是第一条语句） static static变量：只有一份，属于类，可以类名. Static变量 static方法: 类名. Static方法，不能出现this和super static代码块：只执行一次，最早执行的（类第一次调用） package import 包：作用 导入： 1import com.bjsxt.oop.*; 静态导入： 1import static java.lang.Math.PI; Static 单例模式123456789101112131415161718192021222324252627282930313233343536373839404142434445package 单例02;public class GoodsInfo &#123;public void showGoodsInfo() &#123;System.out.println(&quot;商品详情&quot;);UserInfo info = UserInfo.getUserInfo();System.out.println(info.userName+info.psw);&#125;&#125;package 单例02;import java.util.Scanner;public class UserInfo &#123;String userName;String psw;static UserInfo info;public static UserInfo getUserInfo() &#123;if (info == null) &#123;info = new UserInfo();Scanner input = new Scanner(System.in);System.out.println(&quot;请输入用户名&quot;);info.userName = input.next();System.out.println(&quot;请输入密码&quot;);info.psw = input.next();&#125;return info;&#125;&#125;package 单例02;public class Test &#123;public static void main(String[] args) &#123;UserInfo info = UserInfo.getUserInfo();GoodsList list = new GoodsList();list.showGoodsList();GoodsInfo ginfo = new GoodsInfo();ginfo.showGoodsInfo();&#125;&#125;package 单例02;public class GoodsList &#123;public void showGoodsList() &#123;System.out.println(&quot;商品列表&quot;);UserInfo info = UserInfo.getUserInfo();System.out.println(info.userName);System.out.println(info.psw);&#125;&#125; 静态代码块 在类被加载时会使用。 构造方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package 构造方法;public class Dog &#123; String name; int age; /** * 构造方法是创建对象的时候自动调用的方法 * 构造方法的名字必须跟类名保持一致 * 构造方法返回的类型是当前类的类型，但是在定义方法的时候无需声明返回值 * 同时构造方法也不能return * * 当一个类中没有任何构造方法，系统会自动生成一个无参的构造方法 * 如果类中声明了构造方法，则系统不会再生成无参构造方法 * * 构造方法也可以重载 */ public Dog()&#123; name = &quot;旺财&quot;; age = 2; System.out.println(&quot;无参构造&quot;); &#125; public Dog(String name)&#123; name = &quot;旺财&quot;; age = 2; &#125; public Dog(String name,int age) &#123; //this在构造方法中可以用来调用其他的构造方法 //必须出现在构造方法的第一行 this(); this.name = name; this.age = age; &#125; &#125;package 构造方法;public class Test &#123; public static void main(String[] args) &#123;// Dog wangcai = new Dog();// wangcai.name = &quot;旺财&quot;;// wangcai.age = 10; Dog dahuang = new Dog(&quot;大黄&quot;, 10); &#125;&#125; 面向对象的三大基本特征：封装、继承、多态程序设计追求的是：高内聚 低耦合 高内聚：就是类的内部数据操作细节自己完成，不允许外部干涉 低耦合：仅暴露少量的方法给外部使用 使用访问控制符，实现封装 成员（成员变量或成员方法）访问权限共有四种： public 公共的 可以被项目中所有的类访问。(项目可见性) protected 受保护的 可以被这个类本身访问；同一个包中的所有其他的类访问；被它的子类（同一个包以及不同包中的子类）访问 default／friendly 默认的/友好的（包可见性） 被这个类本身访问；被同一个包中的类访问。 private 私有的 只能被这个类本身访问。（类可见性） 类的访问权限只有两种 public 公共的 可被同一项目中所有的类访问。 (必须与文件名同名) default／friendly 默认的/友好的 可被同一个包中的类访问。 封装要点： •类的属性的处理: 1.一般使用private. (除非本属性确定会让子类继承) 2.提供相应的get/set方法来访问相关属性. 这些方法通常是public，从而提供对属性的读取操作。 （注意：boolean变量的get方法是用：is开头!） •一些只用于本类的辅助性方法可以用private •希望其他类调用的方法用public]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 笔记4]]></title>
    <url>%2F2019%2F04%2F23%2Fjava%E7%AC%94%E8%AE%B04%2F</url>
    <content type="text"><![CDATA[数组1.数组是一个变量，用来储存一组相同数据类型的数据 2.声明一个变量就是在内存空间划出一块适合的空间 3.声明一个数组就是在内存中划出一串连续的空间 4.数组是相同类型数据的有序集合. 5.相同类型的若干个数据,按照一定先后次序排列组合而成。 6.其中,每一个数据称作一个数组元素 7.每个数组元素可以通过一个下标来访问它们. 数组的结构和基本要数*标识符:数组的名称，用于区分不同的数组 *数组元素:向数组中存放的数据 *元素的索引(下标|角标)：对数组元素进行编号 *元素类型：数组元素的数据类型 注意: ​ 1.数组只有一个名称，即标识符 ​ 2.元素索引标明了元素在数组中的位置，下标从0开始 ​ 3.数组中的每个元素都可以通过索引来访问 ​ 4.数组长度固定不变，避免数组索引越界 ​ 5.数组变量属于引用数据类型 数组特点:其长度是确定的。数组一旦被创建，它的大小就是不可以改变的。 其元素必须是相同类型,不允许出现混合类型。 数组中的元素可以是任何数据类型，包括基本类型和引用类型。 位置有顺序 数组属引用类型 length, elements of the array 一维数组的声明方式有两种： ​ 123type[] arr_name;type arr_name[]; 数组初始化动态初始化 数组定义与为数组元素分配空间并赋值的操作分开进行。 123451 int a[] = null;2 a = new int[3];3 a[0] = 3;4 a[1] = 9;5 a[2] = 8; 静态初始化：除了用new关键字来产生数组以外,还可以直接在定义数组的同时就为数组元素分配空间并赋值。 格式: 类型 [] 数组名 = {元素1, 元素2 ……} int [] a = {1, 2, 3, 4, 5}; 静态赋值:就是在程序运行之前,就很明确的知道数组中存放的数据是什么,静态赋值不能先声明后赋值,使用new情况除外 动态初始化： 动态地从键盘录入数组中的元素 12345int [] score = new int[30]; Scanner input = new Scanner(System.in); for (int i = 0; i &lt; 30; i++) &#123; score[i]= input.nextInt() &#125; ​ 数组的界限定义并用运算符new为之分配空间后，才可以引用数组中的每个元素； 数组元素的引用方式： 1arrayName[index] index为数组元素下标，可以是整型常量或整型表达式。如a[3] , b[i] , c[6*i]; 数组元素下标从0开始；长度为n的数组合法下标取值范围： 0 ~ n-1 每个数组都有一个属性length指明它的长度，例如：a.length 指明数组a的长度(元素个数)； 数组的长度: 数组名.length 遍历数组中的元素12345for循环//array.length; 数组中元素的个数for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(array[i]);&#125; 1234567加强for循环//加强for循环 foreach 循环//int 指的是数组中元素的类型//i 是迭代变量,就是临时变量array1 是数组的名字for (int i : array1) &#123;System.out.println(i);&#125; 数组的插入​ 元数组为{12,34,40,65,89},将56插入到数组中,使数组还保持升序 ​ 步骤 [12,34,45,65,89,0] ​ 1,找到第一个大于56的数的下标index, 即为56插入的位置 ​ 2,创建一个新的数组长度为原数组+1,使用循环,将原数组的元素拷贝至新数组 ​ 3,新数组从index开始每个元素都后移一位 ​ 4,将56 插入到index位置 1234567891011121314151617181920212223242526272829303132333435363738package 数组常用的操作;/** * * @author Administrator * */public class Test02 &#123; public static void main(String[] args) &#123; int [] arr01 = &#123;12,34,40,65,89&#125;; //创建一个新的数组，长度为原数组长度加1 int [] arr02 = new int[arr01.length+1]; //将原数组的元素一一拷贝到新数组中 for (int i = 0;i&lt;arr01.length;i++)&#123; arr02[i] = arr01[i]; &#125; //[2]在arr02找到第一个比56大的数组 保存下标 int index = 0; for(int i =0;i&lt;arr02.length;i++)&#123; if (arr02[i] &gt;56)&#123; index = i ; break; &#125; &#125; //[3]从index开始 所有元素都往后移动一位 //[12,34,40,65,89,0] for (int i =arr02.length-1; i&gt; index ;i--)&#123; arr02[i] = arr02[i-1]; &#125; //【4】将56插入到index的位置 arr02[index] = 56; for(int i:arr02)&#123; System.out.println(i); &#125; &#125;&#125; 冒泡排序排序算法 什么是冒泡排序呢? ​ 冒泡排序是计算机领域一种较简单的排序算法。 ​ 它重复地访问要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。访问数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 ​ 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名“冒泡排序” 。 原理: 1.比较相邻的元素。如果第一个比第二个大，就交换他们两个 2.对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数 3.针对所有的元素重复以上的步骤，除了最后一个(因为最后一个是最大的，不需要比较) 4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较(最后一个数不需要比较，因为它是最小的) 什么时候用到排序？ 总结: ​ 升序排列时，比较的时候如果满足条件就交换值，每次可以确定一个最大值。 ​ 不用与每次确定下来的最大值最大值进行比较 ​ 确定了倒数第二打的值，那个最小的值不用与其余的值比较 ​ 有排行榜的位置就涉及到排序，范围之广，用处之多大家可以体会得到排序的重要性 123456789101112131415161718192021222324252627282930public class MaoPao &#123; public static void main(String[] args) &#123; int [] arr = &#123;91,10,31,109,2,33&#125;; for (int i = 0;i &lt; arr.length-1;i++)&#123; //外层循环循环一次 冒出来一个最值 ，长度为n 的数组 冒出来n-1个最值就可以排好序了 //所以判断条件是i &lt; arr.length-1; for (int j = 0;j &lt; arr.length-i-1;j++)&#123; //因为外层循环循环一次就冒出来一个最大值 该最大值就不用在参与比较了 //所以判断条件后面要 -i //又因为在内存循环中每次取出两个元素 一个下标为j 一个下标为j+1 //所以j最大值只能取到arr.length-2; //j+ 1的值最大就是arr.length -1 就是最后一个元素了 int n1 = arr[j]; int n2 = arr[j+1]; //比较两个元素 如果前者大于后者 则交换位置 if(n1 &gt; n2)&#123; arr[j] = n2; arr[j+1] = n1; &#125; &#125; &#125; for(int i :arr)&#123; System.out.println(i); &#125; &#125;&#125; 选择排序什么是选择排序呢? ​ 选择排序是一种简单直观的排序算法。 ​ 用第一个元素依次以后面的比较，满足条件则交换。 ​ 如果是升序每次可以确定一个最小值 ​ 如果是降序每次可以确定一个最大值 升序情况下: ​ 用第一个元素与后面的依次比较以后就可以确定第一个元素是最小值，然后就用第二个元素去比较确定倒数第二小的值，以此类推，比较到倒数第二个元素确定时，最后一个元素就是最大值 12345678910111213int[] a = &#123;9,1,7,5,3&#125;;for(int i = 0;i&lt;a.length -1;i++)&#123; for(int j = i+1;j&lt;a.length;j++)&#123; if(a[i] &gt; a[j])&#123; int temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; &#125;&#125;for(int k : a)&#123; System.out.println(k);&#125; 插入排序原理: ​ 将初始序列中的第一个元素作为一个有序序列，然后将剩下的 n-1 个元素按关键字大小依次插入该有序序列，每插入一个元素后依然保持该序列有序，经过 n-1 趟排序后使初始序列有序 初始序列： 1234567891011int[ ] a = &#123;9,1,7,5&#125;; for(int i = 1;i&lt;a.length;i++)&#123; // 因为值是从第二个位置(索引为1)拿出来的 所以 i 从 1 开始 int temp = a[i]; // 把a[i] 赋值给 temp 变量 int j = i - 1; // j 当作一个索引 ,a[j] 的值就是temp值的前一位值 while(j&gt;=0 &amp;&amp; a[j] &gt; temp)&#123;// a[j] &gt; temp ，把拿出来的值与前面的做比较 a[j+1] = a[j]; // 如果满足条件就把前面的值放到后面来 j--; // j-- , 因为要把拿出来的值依次与前面的值比较， // while里面的 j &gt;=0 ,在这里当 j=0时,j--会索引越界 所以 j&gt;=0 &#125; a[j+1] = temp; // 把拿出来的值放到指定的位置(根据比较的结果来放入)&#125; 二维数组：–实质是每个元素是一维数组的一维数组； 什么是二维数组二维数组本质上是以数组作为数组元素的数组，即“数组的数组”。 二维数组又称为矩阵，行列数相等的矩阵称为方阵 二维数组举例：1int [][] a = &#123;&#123;1,2&#125;,&#123;3,4,0,9&#125;,&#123;5,6,7&#125;&#125;; ​ Java中多维数组不必须是规则矩阵形式 Java中多维数组的声明和初始化应按从高维到低维的顺序进行 编写一应用程序实现下述功能：创建一基本(primitive)数据类型的二维数组并输出各数组元素的值。例如： 12345678910111213141516171819202122package Test;public class erWeishuzu &#123; public static void main(String[] args) &#123; int [][] arr01 = &#123;&#123;1,2,3&#125;,&#123;1,2&#125;,&#123;3,4,5,6&#125;&#125;; //当二维数组中的每一个一位数组长度都相同的时候可以这样声明 int [][] arr02 = new int[3][5]; //当二维数组中的每一个一维数组的长度不确定 int [][] arr03 = new int[3][]; arr03[0] = new int[3]; arr03[1] = new int [2]; arr03[2] = new int [4]; for (int i =0;i&lt; arr01.length;i++)&#123; int [] arr = arr01[i]; for (int j= 0;j&lt; arr.length;j++)&#123; System.out.println(&quot;第&quot;+i+&quot;个一维数组中的第&quot;+j+&quot;个元素是：&quot;+arr[j]); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 笔记2]]></title>
    <url>%2F2019%2F04%2F22%2Fjava%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[•什么是方法–封装在一起来执行操作语句的集合，用来完成某个功能操作 –在某些语言中称为函数或者过程 –特殊的方法main，程序执行的入口 public static void main(String [ ] args){ 实现功能的语句 } –不可能所有的功能都放到main中，需要定义其他方法完成指定功能，需要时调用方法即可。 12345678910111213141516171819202122232425262728293031323334package Test;/** * 2.判断1-100之间有多少个素数并输出所有素数。 * （将判断一个数是否是素数的功能提取成方法， * 在循环中直接调用即可） */public class sushuDemo &#123; public static void main(String[] args) &#123; int count = 0; for (int i =1; i&lt;= 100;i++)&#123; if(isPrime(i))&#123; System.out.println(i); count++; &#125; &#125; System.out.println(&quot;1~100的素数的总数是：&quot;+count); &#125; public static boolean isPrime(int num)&#123; boolean flag =true; int count = 0; int i = 2; if(num ==1)&#123; flag = false; &#125;else&#123; for(i =2;i &lt;=Math.sqrt(num);i++)&#123; if(num%i == 0)&#123; flag = false; return flag; &#125; &#125; &#125; return flag; &#125;&#125; 修饰符：封装性时再讲，决定了方法的工作范围 返回值类型：必选，如果没有返回值，须写void。方法只能返回一个值 方法名： 参数列表：可以0个、1个、多个，需要同时说明类型。称为形式参数 方法体：完成具体功能。如果有返回值，必须有return语句；如果没有返回值，默认最后一条语句是return，可以省略。 方法重载：–一个类中可以定义有相同的名字，但参数不同的多个方法 –调用时，会根据不同的参数表选择对应的方法。 •判断依据 –同一个类 –同一个方法名 –不同：参数列表不同(类型，个数，顺序不同) •注意 –只有返回值不同不构成方法的重载（ int a(String str){}, void a{String i} –只有形参的名称不同，不构成方法的重载 •[1]定义方法可以将功能代码进行封装 •[2]方法只有被调用才会被执行 •[3]方法的出现提高了代码的复用性 •[4]方法中只能调用方法,不可以在方法内部定义方法 *[5]定义方法时,方法的结果应该返回给调用者去处理 方法详细说明 什么是方法？ ​ 我们经常说做事要有方式方法。实现某个目的的具体过程. ​ 例如我们学过 main函数在里面写的排序，求水仙花数等 为什么要用方法？ ​ 例如：有三个人 小明，小华，小红三个人， ​ 老师要求小明把班级语文分数成绩排名 ​ 要求小华把班级数学分数成绩排名 ​ 要求小华把班级英语分数成绩排名 ​ 这个时候都要用到排序，我们此时可以把制作一个排序的方法供他们使用 ​ 这样代码就只用写一次，多次使用，这样就提高了代码的复用性 方法分为两类四种: 12345678&gt; 访问修饰符 是否静态 有无返回值 方法名( 有无参数 )&#123;&gt; &gt; &#125; &gt; //相似与&gt; public static void main(String[] args)&#123;&gt; &gt; &#125;&gt; 一. 无返回值 12345&gt; // 1.无参数无返回值&gt; public static void demo1()&#123;&gt; System.out.println(&quot;我是无参数无返回值&quot;);&gt; &#125;&gt; 1234567&gt; // 1.有参数无返回值&gt; // 何为参数？ f(x)这个函数里面的 x 就叫做参数&gt; public static void demo2(int i)&#123;// int i 就是参数 &gt; System.out.println(i);&gt; &#125;&gt; 练习: 传递一个一维数组，求出最大值。&gt; 1.定义方法的步骤是什么? ​ 定义方法有两个明确: ​ a.是否有返回值 ​ b.是否有未知参，参与运算 2.方法的执行流程是什么? ​ 自己定义的方法不被调用的时候是不会被执行的。 ​ 在主函数里直接写上方法的名字即可(要考虑是否需要参数) 调用者: 主函数，main 执行者: 某一个方法本身 实际参数: 实际参与运算的数据 形式参数: 方法小括号里的变量 二.有返回值 1234567891011&gt; // 1. 无参数有返回值 &gt; // 什么是返回值？ 把void这个关键字改为 数据类型时就说明这个方法是有返回值的&gt; // 怎么返回？ 用 return 关键字， 返回的值的类型与方法上面的数据类型一致&gt; public static int demo3()&#123;&gt; return 5; // 返回值，顾名思义返回的是一个值&gt; &#125;&gt; public static int demo4()&#123;&gt; int a = 5;&gt; return a;&gt; &#125;&gt; 123456&gt; //2.有参数有返回值&gt; public static int demo5(int i)&#123;&gt; &gt; return i;&gt; &#125;&gt; 注意: ​ 其实每一个方法最后一行都有一个return，没有返回值可以省略不写，但系统会帮我们添加一个，其作用就是为了结束方法 ​ 如果手动的写出 return 就不允许带回任意的数据。 1234&gt; public static void test()&#123;&gt; return;&gt; &#125;&gt; 定义及使用方法的注意事项有哪些？ ​ 1.方法不能定义在另外一个方法的里面 ​ 2.写错方法名字 ​ 3.写错了参数列表 ​ 4.方法返回值是void，方法中可以省略return 不写 ​ （return 后面与下面不能有代码） ​ 5.方法返回值类型和return 后面数据类型必须匹配 ​ 6.调用方法的时候，返回值void不能写在输出语句中 练习： addition、subtract、 multiply、division 传递数组排序 方法的重载 什么是方法的重载? ​ 在同一个类中： ​ 方法名相同 ​ 参数列表不同(参数的顺序、个数、类型) ​ 和返回值无关 1234567891011121314151617181920212223&gt; public static void test1()&#123;&gt; &gt; &#125;&gt; public static void test2(int i)&#123;&gt; &gt; &#125;&gt; public static void test3(String name)&#123;&gt; &gt; &#125;&gt; public static void test4(char sex)&#123;&gt; &gt; &#125;&gt; public static void test5(double weight)&#123;&gt; &gt; &#125;&gt; public static void test6(int i,int j)&#123;&gt; &gt; &#125;&gt; public static void test7(int i,String name)&#123;&gt; &gt; &#125;&gt; ..........&gt; 方法参数分两种： ​ 一.基本数据类型 ​ 基本数据类型的变量当做参数传递的时候，是不改变原值 ​ 方法的局部变量会随着方法的执行完毕而被释放 ​ 局部变量: ​ 定义在方法的声明上和 方法体内 ​ 二.引用数据类型 ​ 引用数据类型当做参数传递，其实传递的是地址值，是改变原值 ​ 即使方法执行完毕，但是实体(对象、数组)还在对内存中，所以在主函数里面继续访问的时候，已经是被更改后的值 •什么是递归（recursion） –程序调用自身的编程技巧称为递归。 –一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法 –递归问题的特点 1.一个问题可被分解为若干层简单的子问题 2.子问题和其上层问题的解决方案一致 3.外层问题的解决依赖于子问题的解决 12345678910111213141516171819202122package Test;import java.rmi.dgc.DGC;/** * 4. 编写递归算法程序：一列数的规则如下: * 1、1、2、3、5、8、13、21、34...... * 求数列的第40位数是多少。 * @author Administrator * */public class digui &#123; public static void main(String[] args) &#123; System.out.println(&quot;结果是：&quot;+Dg(2)); &#125; public static int Dg(int i) &#123; if(i &lt;= 0)&#123; return 0; &#125;else if(i&gt;0 &amp;&amp; i&lt;= 2)&#123; return 1; &#125; return Dg(i-1)+Dg(i-2); &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录生活的点点滴滴]]></title>
    <url>%2F2019%2F04%2F20%2F%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[摘要：命里有时终须有，命里无时莫强求。 正文：人的眼睛有5.76亿像素,但却终究看不懂人心. 喵喵喵]]></content>
  </entry>
  <entry>
    <title><![CDATA[java 笔记]]></title>
    <url>%2F2019%2F04%2F20%2Fjava%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[数据类型和运算符 标识符常作用 常量、变量、方法、类和包等的名称 命名规则 必须以字母、_下划线、美元符$开头。 其它部分可以是字母、下划线“_”、美元符“$”和数字的任意组合 大小写敏感，长度无限制。 不可以是Java的关键字。 注意 Java不采用通常语言使用的ASCII字符集 Java采用unicode这样的标准的国际字符集。因此，这里的字母的含义：英文、汉字等等。(不建议大家使用汉字来定义标识符！） 常量和变量常量变量定义 在程序中存在大量的数据来代表程序的状态，其中有些数据在程序的运行过程中值会发生改变，有些数据在程序运行过程中值不能发生改变，这些数据在程序中分别被叫做变量和常量。 变量举例： 在2D游戏程序中，需要代表人物的位置，则需要2个变量，一个是x坐标，一个是y坐标，在程序运行过程中，这两个变量的值会发生改变 常量举例 代表常数，便于程序的修改（例如：圆周率的值） 增强程序的可读性（例如：常量UP、DOWN、LEFT和RIGHT分辨代表上下左右，其数值分别是1、2、3和4） 在实际的程序中，可以根据数据在程序运行中是否发生改变，来选择应该是使用变量代表还是常量代表 数据类型byte：Java中最小的数据类型，在内存中占8位(bit)，即1个字节，取值范围-128~127，默认值0 short：短整型，在内存中占16位，即2个字节，取值范围-32768~32717，默认值0 int：整型，用于存储整数，在内在中占32位，即4个字节，取值范围-2147483648~2147483647，默认值0 long：长整型，在内存中占64位，即8个字节-2^63~2^63-1，默认值0L float：浮点型，在内存中占32位，即4个字节，用于存储带小数点的数字（与double的区别在于float类型有效小数点只有6~7位），默认值0 double：双精度浮点型，用于存储带有小数点的数字，在内存中占64位，即8个字节，默认值0 char：字符型，用于存储单个字符，占16位，即2个字节，取值范围0~65535，默认值为空 boolean：布尔类型，占1个字节，用于判断真或假（仅有两个值，即true、false），默认值false 浮点型变量：float类型：单精度类型，尾数可以精确到7位有效数字，在很多情况下，float类型的精度很难满足需求。 double类型：双精度类型 精度是float类型的两倍，尾数可以精确到16位有效数字，绝大部分应用程序都采用double类型。 注意 浮点常量默认为double。要变为float，需在后面增加F/f. 如： 3.14F 浮点数存在舍入误差，很多数字不能精确表示。如果需要进行不产生舍入误差的精确数字计算，需要使用BigDecimal类。 算术 单目：~（按位取反）、! (取非)、-（负号运算符）、 ++（自增）、 - -（自减）、 双目：+ - * / %（取余） 三目：a&gt;b?true:false 说明：当a大于b的时候，为true（也就是冒号之前的值），否则为false；这整个运算符包括一个关系运算符（可以是“&gt;””&lt;””!=”等等），一个“？”，一个“：”，冒号前后需要有两个或者是值或者是对象。 关系 等于符号:==，不等于符号:!= ，大于符号:&gt;， 小于符号:&lt;，大于等于符号 :&gt;= ，小于等于符号:&lt;= 。 *位与逻辑 位运算符 与（&amp;）、非（~）、或（|）、异或（^） &amp;：双目运算符，运算时均把运算数转换为二进制再做比较，规则：当相同的位上均为1时结果为1，否则结 果为0.如：1010&amp;1101，转为二进制：1111110010&amp;10001001101，比较结果为：1000000转为十进制： 64。所以1010&amp;1101=64； | ：当两边操作数的位有一边为1时，结果为1，否则为0。如1100|1010=1110 ~：0变1,1变0 ^：两边的位不同时，结果为1，否则为0.如1100^1010=0110 逻辑运算符 与（&amp;&amp;）、非（!）、或（||） 赋值 = += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= 基本数据类型的类型转换 在赋值运算或算术运算时，要求数据类型相同，否则要进行类型转换 转换方式： 自动转换 强制转换 除boolean类型外，所有的基本数据类型因为各自的精度不同，赋值时都要考虑这个问题 除boolean类型外，所有的基本数据类型包括：整型，浮点型，字符型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package 类型转换;/** * 基本数据类型的类型转换 * @author tang * * 类型转换分为两种情况 * 一，自动类型转换 * 1，低精度 向高精度转换 * 2，低位向高位转换 * 二，强制类型转换 * 1，高精度向低精度转换 * 可能会损失精度 * 2，高位向低位转换 * 可能会损失大小 * */public class Test &#123; public static void main(String[] args) &#123; int a = 10; float f = 1.23f; f = a; long lo = 123L; //__________________________ int b = 270; byte bt = (byte)b; System.out.println(bt); //00000001 00001110 f = 3.14f; int c = (int)f; System.out.println(c); &#125;&#125;package test;import java.util.Scanner;/** * 练习3:商场推出幸运抽奖活动 根据抽奖规则计算会员卡号各位数字之和为16,则为幸运会员 * @author tang * */public class Test03 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入四位数的会员卡卡号&quot;); //接收到用户输入的卡号 int cardNo = input.nextInt(); //求出卡号千位上的数字 int k = cardNo/1000; //求出卡号百位上的数字 int b = (cardNo%1000)/100; //求出卡号十位上的数字 int s = (cardNo%100)/10; //求出卡号个位上的数字 int g = cardNo%10;// 求和 int sum = k + b + s + g; String message = (sum == 16)?&quot;恭喜你，中奖了！&quot;:&quot;很遗憾，本次没有中奖&quot;; System.out.println(message); ​]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle入门到删库01]]></title>
    <url>%2F2019%2F04%2F20%2Foracle%E5%85%A5%E9%97%A8%E5%88%B0%E5%88%A0%E5%BA%9301%2F</url>
    <content type="text"><![CDATA[oracle 是一种关系型数据库 1.使用scott用户登录，需要先解锁 （1）使用DBA登录 （2）解锁命令：alter user scott account unlock|lock; 常用命令 (a)sqlplus 1.sqlplus /nolog 不登录 匿名连接到数据库 首先做次操作 2.conn scott/tiger@orcl 3.show user 4.set linesize 150 5.set pagesize 20 6.Passw 修改密码 7.conn sys/abc123456@orcl as sysdba (b)alter user scott account unlock (a)统一密码：123 (b)使用管理账号 (c)sqplus 1.spool on 开始写入 1.spool d:/test.txt 写入路径 2.select * from emp; 查询结果 3.spool off 写入完毕 distinct 取出重复数据 出现在distinct 后面的所有字段都是重复的，系统才会认为这些数据是重复数据。 例子：select distinct e.sal from emp e where 后面的条件 – ＝，！＝,&lt;&gt;，&lt;,&gt;,&lt;=,&gt;=,any,some,all – 部门编号不是10的员工 例子：select *from emp e where e.deptno &lt;&gt; 10; – &gt;all（） 相当于是大于最大值 – &gt;some（） 相当于是大于最小值 – &gt; any() 是查询最大和最小值之间 例子：select * from emp e where e.sal &gt; any(2000,5000); is null 和 is not null – oracle 中 null ！= null – 所以判断某个字段是否为null 要用 is null 或 is not null – 查询奖金不为空的员工 例子：select *from emp e where e.comm is not null between x and y –查询薪资处于1000-2000之间的员工 例子：select *from emp e where e.sal between 1000 and 2000 in（list），not in（list） –查询部门编号不是10 和 20的员工 例子：select e.*from emp e where e.deptno not in(10,20) exists（sub－query） 子查询有数据则表达式返回true 则执行exists前面的查询语句 select from emp e where exists(select from emp e where 1 = 2) like _ ,%,escape ‘\‘ _\% escape ‘\’ – 将所有名字是以s开头的员工查询出来 – 模糊查询 _ 代表有一个不确定的字符 – % 有多个不确定的字符 列子：select e.ename from emp e where e.ename like ‘%\%%’ escape ‘\’ oracle里面的转义符是自定义的，用escape来定义自己想要的转义符 or 和 and –列出deptno为10或者30，并且工资&gt;2000的所有人。 – and 的优先级高于 or 例子：select *from emp e where (e.deptno = 10 or e.deptno = 30) and e.sal &gt; 2000 order by 按照单个列排序 –order by col 降序和升序 –order by col desc (asc) 按照多个列排序（优先级） –order by col1 desc(asc), col2 desc(asc) –union all 全集 不会去除重复数据 ​ select * from emp e where e.deptno = 10 ​ union all ​ select * from emp e where e.sal &gt; 2000 –union 并集（去重） ​ select * from emp e where e.deptno = 10 ​ union ​ select * from emp e where e.sal &gt; 2000 –intersect 交集 ​ select * from emp e where e.deptno = 10 ​ intersect ​ select * from emp e where e.sal &gt; 2000 –minus 差集 ​ select * from emp e where e.deptno = 10 ​ minus ​ select * from emp e where e.sal &gt; 2000 （NVL(comm,0) comm取空值时用0替代） 例子： select e.ename,(e.sal+nvl(e.comm,0))*12 年收入 from emp e 字符函数 – dual 称之为虚表 用于检测查询语句的语法 – 拼接两个字符串 select concat(‘hello’, ‘nihao’) from dual – 首字母大写 select initcap(e.ename) from emp e – 字符搜索 select instr(‘abcda’,’a’,1,2) from dual –字符串左填充 select lpad(‘abc’,10,’#’) from dual –字符串右填充 select rpad(‘abc’,10,’#’) from dual 日期函数 – 返回系统当前日期 例子：select sysdate from dual – 返回指定月数后的日期 例子：select e.ename,e.hiredate 入职日期,add_months(e.hiredate,6) 转正日期 from emp e – 获取本月最后一天的日期 select last_day(sysdate) from dual – 获取最近的周日 月初 年初 select sysdate 当时日期, round(sysdate) 最近0点日期, round(sysdate,’day’) 最近星期日, round(sysdate,’month’) 最近月初, round(sysdate,’q’) 最近季初日期, round(sysdate,’year’) 最近年初日期 from dual; – 获取本周周日 本月月初 本年年初 select sysdate 当时日期, trunc(sysdate) 今天日期, trunc(sysdate,’day’) 本周星期日, trunc(sysdate,’month’) 本月初, trunc(sysdate,’q’) 本季初日期, trunc(sysdate,’year’) 本年初日期 from dual; — 转换函数 将数字转换为字符串 — 参数1 需要转换为字符串的数字 — 参数2 是规定转换得到的字符串的格式 select to_char(12345,’99,999.99’) from dual – 将日期转换为字符串 select to_char(sysdate,’yyyy-MM-dd HH:mi:ss’) from dual ; select to_char(sysdate,’d’) from dual; – to_date 将表示日期的字符串转换为日期类型 select to_date(‘2018年11月8日’,’YYYY”年”MM”月”DD”日”‘) from dual select to_date(‘2018-11-8’,’YYYY-MM-DD’) from dual Select to_date(‘04,05,19,10,23,40’,’yy,mm,dd,hh12,mi,ss’) from dual; – to_number select to_number(‘$123,456’,’999,999’) from dual — 单行函数嵌套 — 没有上司的人 写为boss select e.ename,nvl(to_char(e.mgr),’boss’) from emp e where e.mgr is null]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 笔记3]]></title>
    <url>%2F2019%2F04%2F20%2Fjava%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[​ 流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块。其流程控制方式采用结构化程序设计中规定的三种基本流程结构，即：顺序结构、分支结构和循环结构，如下图所示： 图示： ​ ​​ if单分支选择结构​ if语句对条件表达式进行一次测试，若测试为真，则执行下面的语句，否则跳过该语句​​ 图示： 12 12345678910111213141516171819202122package ifdemo;public class Test &#123; public static void main(String[] args) &#123; double n1 = 6*Math.random(); double n2 = 6*Math.random(); double n3 = 6*Math.random(); int sum = (int)(n1 + n2 + n3); if (sum &gt;= 15) &#123; System.out.println(&quot;今天手气不错&quot;); &#125; if (sum &gt;= 10 &amp;&amp; sum &lt; 15) &#123; System.out.println(&quot;今天手气一般&quot;); &#125; if (sum &lt; 10) &#123; System.out.println(&quot;今天手气不好&quot;); &#125; System.out.println(&quot;今日运势:&quot;+sum); &#125; if-else**双分支选择结构**当条件表达式为真时，执行语句块1，否则，执行语句块2。也就是else部分图示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package ifdemo;import java.util.Scanner;/**抽奖说明 会员号的百位数字和随机数相等 则会幸运会员 输出 XXXX会员,您是幸运会员,否则输出 XXXX 谢谢您的支持 * @author tang * */public class Test02 &#123; public static void main(String[] args) &#123; //创建一个Scanner的变量 用于输入会员卡卡号 Scanner input = new Scanner(System.in); System.out.println(&quot;请输入会员卡卡号&quot;); int no = input.nextInt(); //获取会员卡百位数字 213 int b = (no%1000)/100; //生成一个0~9的随机数 int number = (int)(10*Math.random()); //判断会员卡卡号百位数字是否和随机数相等 if (b == number) &#123; System.out.println(no+&quot;恭喜您，中奖了&quot;); &#125;else &#123; System.out.println(no+&quot;很遗憾没中奖.谢谢惠顾&quot;); &#125; System.out.println(&quot;程序结束&quot;); &#125;&#125;——————————package ifdemo;import java.util.Scanner;/**小孩搬桌子: 年龄大于7岁可以搬桌子了,大于5岁且为男孩,也可以搬桌子了 否则不可以搬动桌子 你还太年轻了 * @author tang * */public class Test03 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入年龄&quot;); //输入年两 int age = input.nextInt(); System.out.println(&quot;请选择性别:1,男 2,女&quot;); //输入性别 int gender = input.nextInt(); if (age &gt;= 7) &#123; System.out.println(&quot;可以搬桌子&quot;); &#125; if (age &gt;= 5 &amp;&amp; age &lt; 7) &#123; if (gender == 1) &#123; System.out.println(&quot;五岁到七岁之间的男孩可以搬桌子&quot;); &#125;else &#123; System.out.println(&quot;五岁到七岁之间的女孩不可以搬桌子&quot;); &#125; &#125; if (age &lt; 5) &#123; System.out.println(&quot;你不可以搬桌子，太年轻&quot;); &#125; &#125;&#125; If-else if-else**多分支选择结构**if(布尔表达式1) { 语句块1； } else if(布尔表达式2) { 语句块2； }……… else if(布尔表达式n){ ​ 语句块n; } else { ​ 语句块n+1; } 逐条if语句进行判断，条件匹配，进入语句体，否则对if语句继续匹配 1234567891011121314151617181920212223242526272829303132333435363738package ifelseif;import java.util.Scanner;/** * 0~3 婴儿 好好吃奶 * 3~5 儿童 好好玩 * 6~22 少年 好好学习 * 23~60 中年 好好挣钱 * 60~80 中老年 好好补钙 * 80~ 老年 好好晒太阳 * @author tang * * 6~23 精力旺盛 时间充足 财力不足 * 24~60 精力旺盛 时间不足 财力充足 * 60~ 精力不足 时间充足 财力充足 */public class IfElseIf &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入年龄&quot;); int age = input.nextInt(); if (age &lt;= 3) &#123; System.out.println(&quot;婴儿，应该好好吃奶&quot;); &#125;else if(age &lt; 6)&#123; System.out.println(&quot;儿童，好好玩&quot;); &#125;else if(age &lt; 22)&#123; System.out.println(&quot;少年，要好好学习&quot;); &#125;else if(age &lt;= 60)&#123; System.out.println(&quot;中年，要好好工作&quot;); &#125;else if (age &lt;= 80) &#123; System.out.println(&quot;中老年，要补钙&quot;); &#125;else &#123; System.out.println(&quot;老年人，多晒晒太阳&quot;); &#125; System.out.println(&quot;程序结束&quot;); &#125;&#125; while**循环** 在循环刚开始时，会计算一次“布尔表达式”的值，若条件为真，执行循环体。而对于后来每一次额外的循环，都会在开始前重新计算一次。 语句中应有使循环趋向于结束的语句，否则会出现无限循环–––”死”循环。 图示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package whiledemo;/** * 循环4要素 * 1，初始化 * 2，条件判断 * 3，循环体 * 4，迭代 * @author tang * */public class WhileDemo &#123; public static void main(String[] args) &#123; int i = 0;//初始化操作 while(i &lt; 1000)&#123;//条件判断的操作 //循环体 System.out.println(i); //迭代 就是让条件判断趋向于false的操作 i ++; &#125; System.out.println(&quot;程序结束&quot;); &#125;&#125; ---------package test;import java.util.Scanner;/** * 练习3:商场推出幸运抽奖活动 根据抽奖规则计算会员卡号各位数字之和为16,则为幸运会员 * @author tang * */public class Test03 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入四位数的会员卡卡号&quot;); //接收到用户输入的卡号 int cardNo = input.nextInt(); //求出卡号千位上的数字 int k = cardNo/1000; //求出卡号百位上的数字 int b = (cardNo%1000)/100; //求出卡号十位上的数字 int s = (cardNo%100)/10; //求出卡号个位上的数字 int g = cardNo%10;// 求和 int sum = k + b + s + g; String message = (sum == 16)?&quot;恭喜你，中奖了！&quot;:&quot;很遗憾，本次没有中奖&quot;; System.out.println(message); &#125;&#125; switch**多分支选择结构**根据表达式值的不同执行许多不同的操作 switch (表达式) { case 值1 : 语句序列; [break]; case 值2: 语句序列; [break] ; ​ … … … … … [default: 默认语句 ;] } 1.switch语句会根据表达式的值从相匹配的执行，一直执行到break标签处 语句处或者是switch语句的末尾。与任一case值不匹配，则进入default语句(如果有的话) 2.只能处理等值条件判断的情况，且表达式必须为byte，short，int或char类型 ，String 不能是double,float. long 3.常量值必须是与表达式类型兼容的特定的一个常量 4.不允许有重复的case值 5.default子句为可选 123456789101112131415161718192021222324252627282930package switchdemo;/** * 随机生成一个字母，并且判断该字母的类型 * * @author tang * */public class Test &#123; public static void main(String[] args) &#123; int n = (int)(26*Math.random());//产生一个[0,25)的随机数 char flg = (char)(97+n);//产生一个字母 switch (flg) &#123; case &apos;a&apos;: case &apos;e&apos;: case &apos;i&apos;: case &apos;o&apos;: case &apos;u&apos;: System.out.println(&quot;产生了一个元音字母&quot;+flg); break; case &apos;w&apos;: case &apos;y&apos;: System.out.println(&quot;产生了一个半元音字母&quot;+flg); break; default: System.out.println(&quot;产生了一个辅音字母&quot;+flg); break; &#125; &#125;&#125; do-while:先执行，后判断。 while: 先判断，后执行。 While和dowhile的区别： Dowhile总是保证循环体会被至少执行一次！这是他们的主要差别 图示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package Test;import java.util.Scanner;/** * 从键盘输入某个十进制小数，转换成对应的二进制小数并输出。 * @author Administrator * */public class D2Bpoint &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入一个十进制的小数：&quot;); double d = input.nextDouble(); double mul = d; StringBuffer buffer = new StringBuffer(&quot;0&quot;); int count = 0; do&#123; double result = mul*2; int i = (int)result; buffer.append(i); count++; if(count == 7)&#123; break; &#125; mul = result - i; &#125;while(mul != 0); System.out.println(d+ &quot;转化成二进制小数位：&quot;+buffer); &#125;&#125;---------package Test;/** * 6.从键盘输入某个十进制整数数，转换成对应的二进制整数并输出。 * @author Administrator *用2整除十进制整数，可以得到一个商和余数；再用2去除商， *又会得到一个商和余数，如此进行，直到商为小于1时为止， *然后把先得到的余数作为二进制数的低位有效位， *后得到的余数作为二进制数的高位有效位，依次排列起来。 */import java.util.Scanner; public class Test10to2 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入一个十进制的整数：&quot;); int num = input.nextInt(); int num2 = num; String str = &quot;&quot;; do&#123; int div = num/2 ; int mod = num%2 ; str = mod + str; num = div; &#125;while(num != 0); System.out.println(num2+&quot;转换成二进制为：&quot;+str); &#125; &#125; for循环 •for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构 •语法形式 • for (初始表达式;布尔表达式;步进) { –循环体； •} •注意事项 –for循环在执行条件测试后，先执行程序部分，再执行步进。 –在for语句的初始化部分声明的变量，其作用域为整个for循环体 –“初始化”和“循环条件表达式”部分可以使用逗号来执行多个操作 –如果三个部分都为空语句（分号不能省），相当于一个无限循环 跳转语句—break和continue •在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中剩余的语句。(break语句还可用于多支语句switch中) •continue 语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。 跳转语句 —return return语句从当前方法退出，返回到调用该方法的语句处，并从该语句的下条语句处继续执行程序。 返回语句的两种格式（具体到方法时详细讲解） 1、return expression 返回一个值给调用该方法的语句。 返回值的数据类型必须和方法声明中的返回值类型一致或是精度低于声明的数据类型。 2、return 当方法声明中用void声明返回类型为空时，应使用这种返回类型，它不返回任何值。 •break –switch语句–循环语句 •continue –循环语句 •return–任何语句中，结束当前方法，和循环其实没有什么关系 •Continue 只能用于循环中 while do-while 执行了continue 以后 代码回到执行判断的地方,重新判断是否决定下一次执行 •在for循环中执行continue 直接跳到i++迭代处 多重循环（循环嵌套） 一个循环体内又包含另一个完整的循环结构 任何两种循环都可以相互嵌套 可以任意层次循环，但是一般不超过3层 多重循环执行过程 外层循环变量变化一次，内层循环变量要变化一遍 12345678910111213141516171819202122232425262728293031323334package duochongxunhuan;import java.awt.Choice;import java.util.Scanner;/**- 有5家衣服专卖店，每家最多购买3件。用户可以选择离开，可以买衣服。最后打印总共买了几件衣服 思路 外层循环控制去每个专卖店 内层循环控制买衣服过程 使用break退出内层循环- @author Administrator * */ public class BreakDemo &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int count = 0; for (int i = 1;i &lt; 5; i++)&#123; System.out.println(&quot;欢迎光临第&quot;+ i +&quot;家专卖店&quot;); for(int j = 0;j &lt; 3;j++ )&#123; System.out.print(&quot;要离开吗？（y/n)?&quot;); String choice = input.nextLine(); if(&quot;y&quot;.equals(choice))&#123; break; &#125; System.out.println(&quot;买了一件衣服&quot;); count++; &#125; System.out.println(&quot;离店结账&quot;); System.out.println(&quot; &quot;); &#125; System.out.println(&quot;总共买了&quot;+count+&quot;件衣服&quot;); &#125; &#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
