<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java 笔记6]]></title>
    <url>%2F2019%2F04%2F29%2Fjava%E7%AC%94%E8%AE%B06%2F</url>
    <content type="text"><![CDATA[继承 类是对对象的抽象，继承是对某一批类的抽象，从而实现对现实世界更好的建模。 提高代码的复用性！ extends的意思是“扩展”。子类是父类的扩展 父类：超类、基类、 子类：派生类 小结： 继承的作用：通过继承可以简化类的定义，实现代码的重用 子类继承父类的成员变量和成员方法，但不继承父类的构造方法 –java中只有单继承 ，没有像c++那样的多继承。多继承会引起混乱，使得继承链过于复杂，系统难于维护。就像我们现实中，如果你有多个父母亲，那是一个多么混乱的世界啊。多继承，就是为了实现代码的复用性，却引入了复杂性，使得系统类之间的关系混乱。 –java中的多继承，可以通过接口来实现 –如果定义一个类时，没有调用extends，则它的父类是： 12&gt; java.lang.Objec&gt; 子类可以继承父类的所有资源吗？ 不能，不能被继承的父类成员有 1、private成员 2、子类和父类不再同包，使用默认访问权限的成员 3、构造方法 12345678910111213141516package finaldemo;/**- 1,用final来修饰一个变量， 则该变量就变成了一个常量- 2,用final来修饰一个类，则该类就不能被作为父类继承- 3,用final来修饰一个方法，则该方法就不能被重写- @author tang * */ public class Test &#123; public static void main(String[] args) &#123; final int AGE; AGE = 10; &#125; &#125; 方法的重写（override）在子类中可以根据需要对从基类中继承来的方法进行重写。 重写方法必须和被重写方法具有相同方法名称、参数列表和返回类型。 重写方法不能使用比被重写方法更严格的访问权限。（由于多态） 为什么需要重写父类的方法?父类实现的方法不符合子类的逻辑 父类已经实现了80%,但是子类又必须要使用剩下的20%,所以可以重写父类方法,在方法内用super关键字调用父类的方法,再去完成剩下的20%工作 super关键字定义：super是直接父类对象的引用。 用法：可以通过super来访问父类中被子类覆盖的方法或属性。 普通方法： 没有顺序限制。可以随便调用。 构造函数中： 任何类的构造函数中，若是构造函数的第一行代码没有显式的调用super(…);那么Java默认都会调用super();作为父类的初始化函数。 所以你这里的super();加不加都无所谓。 final关键字定义：final可以用来修饰变量，方法，类。 修饰变量 变量一旦被初始化便不可改变 相当于定义了一个常量 ​ 2.修饰引用数据类型 引用不能被赋值 但属性可以被赋值 ​ 3.修饰方法 final方法是在子类中不能被覆盖的方法 ​ 4.修饰类 final类是无法被任何类继承的 Object类object类是所有java类的根基 如果在类的声明中未使用extends关键字指明其基类，则默认基类为object类 重写：1toString 方法： 默认返回：包名+类名+@+哈希码 可以重写！ 抽象类定义：是一种模版模式。抽象类为所有子类提供了一个通用模版，子类可以在这个模版基础上进行扩展。 作用： 通过抽象类，可以避免子类设计的随意性。通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package 抽象类;/**- class 前加abstract 该类就成为了一个抽象类- 1，抽象类不能创建对象- 2，抽象类一般是一个父类，该父类没有什么存在的意义，就是用来被子类继承 - 3，抽象类中可以有抽象方法，也可以有非抽象方法- 4，一个类继承了一个抽象类，则该类必须要实现该抽象类中的所有抽象方法- 5，如果子类也是抽象类，则可以不实现父类的抽象方法- 6，抽象方法必须定义在抽象类中- - - 为什么要使用抽象类- - @author tang * */ public abstract class Pet &#123; private String name; //抽象方法 //如果一个方法 每个子类实现的逻辑都不一样 则把该方法定义成抽象方法， //让每个子类去根据自己的逻辑实现该方法 public abstract void bark(); public abstract void eat(); public abstract void sleep(); public abstract void play(); //如果一个方法，每个子类实现的逻辑都一样 则该方法直接在父类中实现，子类直接调用 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;package 抽象类;public class Dog extends Pet&#123;​ public void bark() { System.out.println(“won won won…”);} public void eat() { System.out.println(“狗喜欢吃骨头”);} public void sleep() { System.out.println(“狗在睡觉。。。”);} public void play() { System.out.println(“狗在玩飞盘。。。”);}​1234567&#125;package 抽象类;public class Cat extends Pet&#123;​ public void bark() { System.out.println(“maio miao …”);} public void eat() { System.out.println(“猫在吃鱼。。。”); } public void sleep() { System.out.println(“猫在晒太阳。。。”);} public void play() { System.out.println(“猫在玩老鼠。。。”);}​12&#125; 总结： 抽象方法和抽象类均必须用abstract来修饰。 抽象方法没有方法体，只需要声明不需实现。 有抽象方法的类只能定义能抽象类 相反抽象类里面的方法不一定全是抽象方法，也可能没有抽象方法。 抽象类可以包含属性、方法、构造方法。 抽象类不能实例化，及不能用new来实例化抽象类，只能用来被子类调用。 抽象类只能用来继承。 抽象方法必须被子类实现。抽象类的子类必须覆盖所有的抽象方法才能被实例化，否则还是抽象类 构造方法调用顺序： 根据super的说明，构造方法第一句 总是：super(…)来调用父类对应的构造方法。 先向上追溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止 对象的比较** ==和equals()** ==： 比较两基本类型变量的值是否相等 比较两个引用类型的值即内存地址是否相等，即是否指向同一对象 equals() ： 两对象的内容是否一致 自定义类须重写equals()，否则其对象比较结果总是false。 12345678910111213141516171819202122232425262728package equalsdemo;/**- 判断相等的两种方式 * *1， == - 用来判断基本数据类型的数据是否相等- 也可以用来判断引用数据类型 判断两个引用是否相等 当且仅当两个引用指向的是同一个对象 == 判断才返回true- - *2，equals - 判断引用数据类型的对象是否相等- 如果一个类没有重写该方法，则自动调用到Object中的equals 判断规则跟 == 一样- 如果要自定义判断相等的规则，则在本类中重写equals 方法，在方法内定义比较规则- @author tang * */ public class Test &#123; public static void main(String[] args) &#123; String str01 = &quot;abc&quot;; String str02 = new String(&quot;abc&quot;); System.out.println(str01 == str02); System.out.println(str01.equals(str02)); 123&#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 笔记5]]></title>
    <url>%2F2019%2F04%2F26%2Fjava%E7%AC%94%E8%AE%B05%2F</url>
    <content type="text"><![CDATA[面向对象区别： 面向过程：事物比较简单，可以用线性的思维去解决 面向对象：事物比较复杂，使用简单的线性思维无法解决 共同点： 面向过程和面向对象都是解决实际问题的一种思维方式 二者相辅相成，通过面向对象方式方便于我们从宏观上把握事物之间复杂的关系，方便我们分析整个系统，具体到微观操作，仍然使用面向过程方式来处理。 类可以生成对象 类是对象的抽象 对象：是具体的事物 类：是对对象的抽象（抽象 抽出像的部分） 先有具体对象，然后抽象各个对象象的部分，归纳出类通过类在认识其他对象 1、静态的描述声明为类的成员变量 成员变量描述对象有什么 2、动态的描述声明为成员方法 成员方法描述对象可以做什么 3、成员方法可以直接使用成员变量 123456789101112131415161718public class Person &#123;//静态的特征描述为类的成员变量 成员变量描述对象有什么//在这里声明类的成员变量//类的里面 方法的外面String name;int age;String gender;//动态的特征描述为类的成员方法 成员方法描述对象可以做什么public void eat() &#123;//成员方法可以直接使用成员变量System.out.println(name + &quot;在吃饭&quot;);&#125;public void sleep() &#123;System.out.print(name + &quot;在睡觉&quot;);&#125;public void coding() &#123;System.out.print(name + &quot;在敲代码&quot;);&#125;&#125; 类：class 对象：object instance(实例）某个类的对象 &lt;==&gt; 某个类的实例 定义类（类的组成） 属性 field 方法 method 构造方法 construtor 其他：代码块 静态代码块 内部类 类的属性：在定义成员变量时可以对其初始化 如果不对其初始化，Java使用默认的值对其初始化。 创建对象 类名 对象名 = new 类名(); Person p1=new Person(); 调用类的属性和方法 对象名.成员变量 对象名.成员方法 属性 field，或者叫成员变量 属性用于定义该类或该类对象包含的数据或者说静态属性。 属性作用范围是整个类体 内存分析 形参和实参定义方法的参数是形式参数 调用方法的参数是实在参数 调用方法时要求参数个数相同，类型兼容 参数传递 基本数据类型的参数传递 引用数据类型的参数传递 类和类之间的通信 通过创建对象，类和类就建立了联系，通过方法的调用来进行信息的传递 this关键字this的作用: this表示的是当前对象本身， 更准确地说，this代表当前对象的一个引用。 普通方法中使用this。 区分类成员属性和方法的形参. 调用当前对象的其他方法（可以省略） 位置：任意 构造方法中使用this。 使用this来调用其它构造方法 位置：必须是第一条语句 this不能用于static方法。 1234567891011121314151617181920212223242526272829303132333435363738package thisDemo;/** * this 是当前对象的引用 * 哪个对象调用了当前方法 哪个对象就是当前对象 * @author Administrator * */public class Dog &#123; String name; int age; public void test() &#123; System.out.println(this); this.test(); &#125; public void test02() &#123; System.out.println(this); this.test02(); &#125;&#125;package thisDemo;public class Test &#123; public static void main(String[] args) &#123; Dog wangcai = new Dog(); System.out.println(wangcai); wangcai.test(); Dog dahuang =new Dog(); System.out.println(dahuang); dahuang.test(); &#125;&#125; static 关键字在类中，用static声明的成员变量为静态成员变量 ,或者叫做： 类属性，类变量. 它为该类的公用变量，属于类，被该类的所有实例共享，在类被载入时被显式初始化， 对于该类的所有对象来说，static成员变量只有一份。被该类的所有对象共享！！ 可以使用”对象.类属性”来调用。不过，一般都是用“类名.类属性” static变量置于方法区中！ 用static声明的方法为静态方法 不需要对象，就可以调用(类名.方法名) 在调用该方法时，不会将对象的引用传递给它，所以在static方法中不可访问非static的成员。 静态方法不能以任何方式引用this和super关键字 静态初始化块 如果希望加载后，对整个类进行某些初始化操作，可以使用static初始化块。 类第一次被载入时先执行static代码块；类多次载入时，static代码块只执行一次；Static经常用来进行static变量的初始化。 是在类初始化时执行，不是在创建对象时执行。 静态初始化块中不能访问非static成员。 pakage 作用： 为了解决类之间的重名问题。 为了便于管理类：合适的类位于合适的包 用法： 通常是类的第一句非注释性语句。 包名：域名倒着写即可，再加上模块名，并与内部管理类。 注意事项： 写项目时都要加包，不要使用默认包。 com.gao和com.gao.car，这两个包没有包含关系，是两个完全独立的包。只是逻辑上看起来后者是前者的一部分。 JDK中的主要包java.lang 包含一些Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能。 java.awt 包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。 java.net 包含执行与网络相关的操作的类。 java.io 包含能提供多种输入/输出功能的类。 java.util 包含一些实用工具类，如定义系统特性、使用与日期日历相关的函数。 Import 作用：如果不适用import，我们如果用到其他包的类时，只能这么写：java.util.Date，代码量太大，不利于编写和维护。通过import可以导入其他包下面的类，从而可以在本类中直接通过类名来调用。 用法： import java.util.Date; import java.util.*; //导入该包下所有的类。会降低编译速度，但不会降低运行速度。 注意要点： java会默认导入java.lang包下所有的类，因此这些类我们可以直接使用。 如果导入两个同名的类，只能用包名+类名来显示调用相关类： 1java.util.Date date = new java.util.Date(); import static 12–import static java.lang.Math.*;//导入Math类的所有静态属性–import static java.lang.Math.PI;//导入Math类的PI属性 1–然后，我们可以在程序中直接使用：System.out.println(PI); 方法调用中的参数传递（重中之重） 基本数据类型的参数传递：不能改变参数的值 引用数据类型的参数传递：不能改变参数的值 This修饰构造方法（必须是第一条语句） This代表当前对象自身的引用（必须new） This可以修饰属性，区别成员变量和局部变量 This修饰方法 This修饰构造方法（必须是第一条语句） static static变量：只有一份，属于类，可以类名. Static变量 static方法: 类名. Static方法，不能出现this和super static代码块：只执行一次，最早执行的（类第一次调用） package import 包：作用 导入： 1import com.bjsxt.oop.*; 静态导入： 1import static java.lang.Math.PI; Static 单例模式123456789101112131415161718192021222324252627282930313233343536373839404142434445package 单例02;public class GoodsInfo &#123;public void showGoodsInfo() &#123;System.out.println(&quot;商品详情&quot;);UserInfo info = UserInfo.getUserInfo();System.out.println(info.userName+info.psw);&#125;&#125;package 单例02;import java.util.Scanner;public class UserInfo &#123;String userName;String psw;static UserInfo info;public static UserInfo getUserInfo() &#123;if (info == null) &#123;info = new UserInfo();Scanner input = new Scanner(System.in);System.out.println(&quot;请输入用户名&quot;);info.userName = input.next();System.out.println(&quot;请输入密码&quot;);info.psw = input.next();&#125;return info;&#125;&#125;package 单例02;public class Test &#123;public static void main(String[] args) &#123;UserInfo info = UserInfo.getUserInfo();GoodsList list = new GoodsList();list.showGoodsList();GoodsInfo ginfo = new GoodsInfo();ginfo.showGoodsInfo();&#125;&#125;package 单例02;public class GoodsList &#123;public void showGoodsList() &#123;System.out.println(&quot;商品列表&quot;);UserInfo info = UserInfo.getUserInfo();System.out.println(info.userName);System.out.println(info.psw);&#125;&#125; 静态代码块 在类被加载时会使用。 构造方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package 构造方法;public class Dog &#123; String name; int age; /** * 构造方法是创建对象的时候自动调用的方法 * 构造方法的名字必须跟类名保持一致 * 构造方法返回的类型是当前类的类型，但是在定义方法的时候无需声明返回值 * 同时构造方法也不能return * * 当一个类中没有任何构造方法，系统会自动生成一个无参的构造方法 * 如果类中声明了构造方法，则系统不会再生成无参构造方法 * * 构造方法也可以重载 */ public Dog()&#123; name = &quot;旺财&quot;; age = 2; System.out.println(&quot;无参构造&quot;); &#125; public Dog(String name)&#123; name = &quot;旺财&quot;; age = 2; &#125; public Dog(String name,int age) &#123; //this在构造方法中可以用来调用其他的构造方法 //必须出现在构造方法的第一行 this(); this.name = name; this.age = age; &#125; &#125;package 构造方法;public class Test &#123; public static void main(String[] args) &#123;// Dog wangcai = new Dog();// wangcai.name = &quot;旺财&quot;;// wangcai.age = 10; Dog dahuang = new Dog(&quot;大黄&quot;, 10); &#125;&#125; 面向对象的三大基本特征：封装、继承、多态程序设计追求的是：高内聚 低耦合 高内聚：就是类的内部数据操作细节自己完成，不允许外部干涉 低耦合：仅暴露少量的方法给外部使用 使用访问控制符，实现封装 成员（成员变量或成员方法）访问权限共有四种： public 公共的 可以被项目中所有的类访问。(项目可见性) protected 受保护的 可以被这个类本身访问；同一个包中的所有其他的类访问；被它的子类（同一个包以及不同包中的子类）访问 default／friendly 默认的/友好的（包可见性） 被这个类本身访问；被同一个包中的类访问。 private 私有的 只能被这个类本身访问。（类可见性） 类的访问权限只有两种 public 公共的 可被同一项目中所有的类访问。 (必须与文件名同名) default／friendly 默认的/友好的 可被同一个包中的类访问。 封装要点： •类的属性的处理: 1.一般使用private. (除非本属性确定会让子类继承) 2.提供相应的get/set方法来访问相关属性. 这些方法通常是public，从而提供对属性的读取操作。 （注意：boolean变量的get方法是用：is开头!） •一些只用于本类的辅助性方法可以用private •希望其他类调用的方法用public]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 笔记4]]></title>
    <url>%2F2019%2F04%2F23%2Fjava%E7%AC%94%E8%AE%B04%2F</url>
    <content type="text"><![CDATA[数组1.数组是一个变量，用来储存一组相同数据类型的数据 2.声明一个变量就是在内存空间划出一块适合的空间 3.声明一个数组就是在内存中划出一串连续的空间 4.数组是相同类型数据的有序集合. 5.相同类型的若干个数据,按照一定先后次序排列组合而成。 6.其中,每一个数据称作一个数组元素 7.每个数组元素可以通过一个下标来访问它们. 数组的结构和基本要数*标识符:数组的名称，用于区分不同的数组 *数组元素:向数组中存放的数据 *元素的索引(下标|角标)：对数组元素进行编号 *元素类型：数组元素的数据类型 注意: ​ 1.数组只有一个名称，即标识符 ​ 2.元素索引标明了元素在数组中的位置，下标从0开始 ​ 3.数组中的每个元素都可以通过索引来访问 ​ 4.数组长度固定不变，避免数组索引越界 ​ 5.数组变量属于引用数据类型 数组特点:其长度是确定的。数组一旦被创建，它的大小就是不可以改变的。 其元素必须是相同类型,不允许出现混合类型。 数组中的元素可以是任何数据类型，包括基本类型和引用类型。 位置有顺序 数组属引用类型 length, elements of the array 一维数组的声明方式有两种： ​ 123type[] arr_name;type arr_name[]; 数组初始化动态初始化 数组定义与为数组元素分配空间并赋值的操作分开进行。 123451 int a[] = null;2 a = new int[3];3 a[0] = 3;4 a[1] = 9;5 a[2] = 8; 静态初始化：除了用new关键字来产生数组以外,还可以直接在定义数组的同时就为数组元素分配空间并赋值。 格式: 类型 [] 数组名 = {元素1, 元素2 ……} int [] a = {1, 2, 3, 4, 5}; 静态赋值:就是在程序运行之前,就很明确的知道数组中存放的数据是什么,静态赋值不能先声明后赋值,使用new情况除外 动态初始化： 动态地从键盘录入数组中的元素 12345int [] score = new int[30]; Scanner input = new Scanner(System.in); for (int i = 0; i &lt; 30; i++) &#123; score[i]= input.nextInt() &#125; ​ 数组的界限定义并用运算符new为之分配空间后，才可以引用数组中的每个元素； 数组元素的引用方式： 1arrayName[index] index为数组元素下标，可以是整型常量或整型表达式。如a[3] , b[i] , c[6*i]; 数组元素下标从0开始；长度为n的数组合法下标取值范围： 0 ~ n-1 每个数组都有一个属性length指明它的长度，例如：a.length 指明数组a的长度(元素个数)； 数组的长度: 数组名.length 遍历数组中的元素12345for循环//array.length; 数组中元素的个数for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(array[i]);&#125; 1234567加强for循环//加强for循环 foreach 循环//int 指的是数组中元素的类型//i 是迭代变量,就是临时变量array1 是数组的名字for (int i : array1) &#123;System.out.println(i);&#125; 数组的插入​ 元数组为{12,34,40,65,89},将56插入到数组中,使数组还保持升序 ​ 步骤 [12,34,45,65,89,0] ​ 1,找到第一个大于56的数的下标index, 即为56插入的位置 ​ 2,创建一个新的数组长度为原数组+1,使用循环,将原数组的元素拷贝至新数组 ​ 3,新数组从index开始每个元素都后移一位 ​ 4,将56 插入到index位置 1234567891011121314151617181920212223242526272829303132333435363738package 数组常用的操作;/** * * @author Administrator * */public class Test02 &#123; public static void main(String[] args) &#123; int [] arr01 = &#123;12,34,40,65,89&#125;; //创建一个新的数组，长度为原数组长度加1 int [] arr02 = new int[arr01.length+1]; //将原数组的元素一一拷贝到新数组中 for (int i = 0;i&lt;arr01.length;i++)&#123; arr02[i] = arr01[i]; &#125; //[2]在arr02找到第一个比56大的数组 保存下标 int index = 0; for(int i =0;i&lt;arr02.length;i++)&#123; if (arr02[i] &gt;56)&#123; index = i ; break; &#125; &#125; //[3]从index开始 所有元素都往后移动一位 //[12,34,40,65,89,0] for (int i =arr02.length-1; i&gt; index ;i--)&#123; arr02[i] = arr02[i-1]; &#125; //【4】将56插入到index的位置 arr02[index] = 56; for(int i:arr02)&#123; System.out.println(i); &#125; &#125;&#125; 冒泡排序排序算法 什么是冒泡排序呢? ​ 冒泡排序是计算机领域一种较简单的排序算法。 ​ 它重复地访问要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。访问数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 ​ 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名“冒泡排序” 。 原理: 1.比较相邻的元素。如果第一个比第二个大，就交换他们两个 2.对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数 3.针对所有的元素重复以上的步骤，除了最后一个(因为最后一个是最大的，不需要比较) 4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较(最后一个数不需要比较，因为它是最小的) 什么时候用到排序？ 总结: ​ 升序排列时，比较的时候如果满足条件就交换值，每次可以确定一个最大值。 ​ 不用与每次确定下来的最大值最大值进行比较 ​ 确定了倒数第二打的值，那个最小的值不用与其余的值比较 ​ 有排行榜的位置就涉及到排序，范围之广，用处之多大家可以体会得到排序的重要性 123456789101112131415161718192021222324252627282930public class MaoPao &#123; public static void main(String[] args) &#123; int [] arr = &#123;91,10,31,109,2,33&#125;; for (int i = 0;i &lt; arr.length-1;i++)&#123; //外层循环循环一次 冒出来一个最值 ，长度为n 的数组 冒出来n-1个最值就可以排好序了 //所以判断条件是i &lt; arr.length-1; for (int j = 0;j &lt; arr.length-i-1;j++)&#123; //因为外层循环循环一次就冒出来一个最大值 该最大值就不用在参与比较了 //所以判断条件后面要 -i //又因为在内存循环中每次取出两个元素 一个下标为j 一个下标为j+1 //所以j最大值只能取到arr.length-2; //j+ 1的值最大就是arr.length -1 就是最后一个元素了 int n1 = arr[j]; int n2 = arr[j+1]; //比较两个元素 如果前者大于后者 则交换位置 if(n1 &gt; n2)&#123; arr[j] = n2; arr[j+1] = n1; &#125; &#125; &#125; for(int i :arr)&#123; System.out.println(i); &#125; &#125;&#125; 选择排序什么是选择排序呢? ​ 选择排序是一种简单直观的排序算法。 ​ 用第一个元素依次以后面的比较，满足条件则交换。 ​ 如果是升序每次可以确定一个最小值 ​ 如果是降序每次可以确定一个最大值 升序情况下: ​ 用第一个元素与后面的依次比较以后就可以确定第一个元素是最小值，然后就用第二个元素去比较确定倒数第二小的值，以此类推，比较到倒数第二个元素确定时，最后一个元素就是最大值 12345678910111213int[] a = &#123;9,1,7,5,3&#125;;for(int i = 0;i&lt;a.length -1;i++)&#123; for(int j = i+1;j&lt;a.length;j++)&#123; if(a[i] &gt; a[j])&#123; int temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; &#125;&#125;for(int k : a)&#123; System.out.println(k);&#125; 插入排序原理: ​ 将初始序列中的第一个元素作为一个有序序列，然后将剩下的 n-1 个元素按关键字大小依次插入该有序序列，每插入一个元素后依然保持该序列有序，经过 n-1 趟排序后使初始序列有序 初始序列： 1234567891011int[ ] a = &#123;9,1,7,5&#125;; for(int i = 1;i&lt;a.length;i++)&#123; // 因为值是从第二个位置(索引为1)拿出来的 所以 i 从 1 开始 int temp = a[i]; // 把a[i] 赋值给 temp 变量 int j = i - 1; // j 当作一个索引 ,a[j] 的值就是temp值的前一位值 while(j&gt;=0 &amp;&amp; a[j] &gt; temp)&#123;// a[j] &gt; temp ，把拿出来的值与前面的做比较 a[j+1] = a[j]; // 如果满足条件就把前面的值放到后面来 j--; // j-- , 因为要把拿出来的值依次与前面的值比较， // while里面的 j &gt;=0 ,在这里当 j=0时,j--会索引越界 所以 j&gt;=0 &#125; a[j+1] = temp; // 把拿出来的值放到指定的位置(根据比较的结果来放入)&#125; 二维数组：–实质是每个元素是一维数组的一维数组； 什么是二维数组二维数组本质上是以数组作为数组元素的数组，即“数组的数组”。 二维数组又称为矩阵，行列数相等的矩阵称为方阵 二维数组举例：1int [][] a = &#123;&#123;1,2&#125;,&#123;3,4,0,9&#125;,&#123;5,6,7&#125;&#125;; ​ Java中多维数组不必须是规则矩阵形式 Java中多维数组的声明和初始化应按从高维到低维的顺序进行 编写一应用程序实现下述功能：创建一基本(primitive)数据类型的二维数组并输出各数组元素的值。例如： 12345678910111213141516171819202122package Test;public class erWeishuzu &#123; public static void main(String[] args) &#123; int [][] arr01 = &#123;&#123;1,2,3&#125;,&#123;1,2&#125;,&#123;3,4,5,6&#125;&#125;; //当二维数组中的每一个一位数组长度都相同的时候可以这样声明 int [][] arr02 = new int[3][5]; //当二维数组中的每一个一维数组的长度不确定 int [][] arr03 = new int[3][]; arr03[0] = new int[3]; arr03[1] = new int [2]; arr03[2] = new int [4]; for (int i =0;i&lt; arr01.length;i++)&#123; int [] arr = arr01[i]; for (int j= 0;j&lt; arr.length;j++)&#123; System.out.println(&quot;第&quot;+i+&quot;个一维数组中的第&quot;+j+&quot;个元素是：&quot;+arr[j]); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 笔记2]]></title>
    <url>%2F2019%2F04%2F22%2Fjava%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[•什么是方法–封装在一起来执行操作语句的集合，用来完成某个功能操作 –在某些语言中称为函数或者过程 –特殊的方法main，程序执行的入口 public static void main(String [ ] args){ 实现功能的语句 } –不可能所有的功能都放到main中，需要定义其他方法完成指定功能，需要时调用方法即可。 12345678910111213141516171819202122232425262728293031323334package Test;/** * 2.判断1-100之间有多少个素数并输出所有素数。 * （将判断一个数是否是素数的功能提取成方法， * 在循环中直接调用即可） */public class sushuDemo &#123; public static void main(String[] args) &#123; int count = 0; for (int i =1; i&lt;= 100;i++)&#123; if(isPrime(i))&#123; System.out.println(i); count++; &#125; &#125; System.out.println(&quot;1~100的素数的总数是：&quot;+count); &#125; public static boolean isPrime(int num)&#123; boolean flag =true; int count = 0; int i = 2; if(num ==1)&#123; flag = false; &#125;else&#123; for(i =2;i &lt;=Math.sqrt(num);i++)&#123; if(num%i == 0)&#123; flag = false; return flag; &#125; &#125; &#125; return flag; &#125;&#125; 修饰符：封装性时再讲，决定了方法的工作范围 返回值类型：必选，如果没有返回值，须写void。方法只能返回一个值 方法名： 参数列表：可以0个、1个、多个，需要同时说明类型。称为形式参数 方法体：完成具体功能。如果有返回值，必须有return语句；如果没有返回值，默认最后一条语句是return，可以省略。 方法重载：–一个类中可以定义有相同的名字，但参数不同的多个方法 –调用时，会根据不同的参数表选择对应的方法。 •判断依据 –同一个类 –同一个方法名 –不同：参数列表不同(类型，个数，顺序不同) •注意 –只有返回值不同不构成方法的重载（ int a(String str){}, void a{String i} –只有形参的名称不同，不构成方法的重载 •[1]定义方法可以将功能代码进行封装 •[2]方法只有被调用才会被执行 •[3]方法的出现提高了代码的复用性 •[4]方法中只能调用方法,不可以在方法内部定义方法 *[5]定义方法时,方法的结果应该返回给调用者去处理 方法详细说明 什么是方法？ ​ 我们经常说做事要有方式方法。实现某个目的的具体过程. ​ 例如我们学过 main函数在里面写的排序，求水仙花数等 为什么要用方法？ ​ 例如：有三个人 小明，小华，小红三个人， ​ 老师要求小明把班级语文分数成绩排名 ​ 要求小华把班级数学分数成绩排名 ​ 要求小华把班级英语分数成绩排名 ​ 这个时候都要用到排序，我们此时可以把制作一个排序的方法供他们使用 ​ 这样代码就只用写一次，多次使用，这样就提高了代码的复用性 方法分为两类四种: 12345678&gt; 访问修饰符 是否静态 有无返回值 方法名( 有无参数 )&#123;&gt; &gt; &#125; &gt; //相似与&gt; public static void main(String[] args)&#123;&gt; &gt; &#125;&gt; 一. 无返回值 12345&gt; // 1.无参数无返回值&gt; public static void demo1()&#123;&gt; System.out.println(&quot;我是无参数无返回值&quot;);&gt; &#125;&gt; 1234567&gt; // 1.有参数无返回值&gt; // 何为参数？ f(x)这个函数里面的 x 就叫做参数&gt; public static void demo2(int i)&#123;// int i 就是参数 &gt; System.out.println(i);&gt; &#125;&gt; 练习: 传递一个一维数组，求出最大值。&gt; 1.定义方法的步骤是什么? ​ 定义方法有两个明确: ​ a.是否有返回值 ​ b.是否有未知参，参与运算 2.方法的执行流程是什么? ​ 自己定义的方法不被调用的时候是不会被执行的。 ​ 在主函数里直接写上方法的名字即可(要考虑是否需要参数) 调用者: 主函数，main 执行者: 某一个方法本身 实际参数: 实际参与运算的数据 形式参数: 方法小括号里的变量 二.有返回值 1234567891011&gt; // 1. 无参数有返回值 &gt; // 什么是返回值？ 把void这个关键字改为 数据类型时就说明这个方法是有返回值的&gt; // 怎么返回？ 用 return 关键字， 返回的值的类型与方法上面的数据类型一致&gt; public static int demo3()&#123;&gt; return 5; // 返回值，顾名思义返回的是一个值&gt; &#125;&gt; public static int demo4()&#123;&gt; int a = 5;&gt; return a;&gt; &#125;&gt; 123456&gt; //2.有参数有返回值&gt; public static int demo5(int i)&#123;&gt; &gt; return i;&gt; &#125;&gt; 注意: ​ 其实每一个方法最后一行都有一个return，没有返回值可以省略不写，但系统会帮我们添加一个，其作用就是为了结束方法 ​ 如果手动的写出 return 就不允许带回任意的数据。 1234&gt; public static void test()&#123;&gt; return;&gt; &#125;&gt; 定义及使用方法的注意事项有哪些？ ​ 1.方法不能定义在另外一个方法的里面 ​ 2.写错方法名字 ​ 3.写错了参数列表 ​ 4.方法返回值是void，方法中可以省略return 不写 ​ （return 后面与下面不能有代码） ​ 5.方法返回值类型和return 后面数据类型必须匹配 ​ 6.调用方法的时候，返回值void不能写在输出语句中 练习： addition、subtract、 multiply、division 传递数组排序 方法的重载 什么是方法的重载? ​ 在同一个类中： ​ 方法名相同 ​ 参数列表不同(参数的顺序、个数、类型) ​ 和返回值无关 1234567891011121314151617181920212223&gt; public static void test1()&#123;&gt; &gt; &#125;&gt; public static void test2(int i)&#123;&gt; &gt; &#125;&gt; public static void test3(String name)&#123;&gt; &gt; &#125;&gt; public static void test4(char sex)&#123;&gt; &gt; &#125;&gt; public static void test5(double weight)&#123;&gt; &gt; &#125;&gt; public static void test6(int i,int j)&#123;&gt; &gt; &#125;&gt; public static void test7(int i,String name)&#123;&gt; &gt; &#125;&gt; ..........&gt; 方法参数分两种： ​ 一.基本数据类型 ​ 基本数据类型的变量当做参数传递的时候，是不改变原值 ​ 方法的局部变量会随着方法的执行完毕而被释放 ​ 局部变量: ​ 定义在方法的声明上和 方法体内 ​ 二.引用数据类型 ​ 引用数据类型当做参数传递，其实传递的是地址值，是改变原值 ​ 即使方法执行完毕，但是实体(对象、数组)还在对内存中，所以在主函数里面继续访问的时候，已经是被更改后的值 •什么是递归（recursion） –程序调用自身的编程技巧称为递归。 –一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法 –递归问题的特点 1.一个问题可被分解为若干层简单的子问题 2.子问题和其上层问题的解决方案一致 3.外层问题的解决依赖于子问题的解决 12345678910111213141516171819202122package Test;import java.rmi.dgc.DGC;/** * 4. 编写递归算法程序：一列数的规则如下: * 1、1、2、3、5、8、13、21、34...... * 求数列的第40位数是多少。 * @author Administrator * */public class digui &#123; public static void main(String[] args) &#123; System.out.println(&quot;结果是：&quot;+Dg(2)); &#125; public static int Dg(int i) &#123; if(i &lt;= 0)&#123; return 0; &#125;else if(i&gt;0 &amp;&amp; i&lt;= 2)&#123; return 1; &#125; return Dg(i-1)+Dg(i-2); &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录生活的点点滴滴]]></title>
    <url>%2F2019%2F04%2F20%2F%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[摘要：命里有时终须有，命里无时莫强求。 正文：人的眼睛有5.76亿像素,但却终究看不懂人心. 喵喵喵]]></content>
  </entry>
  <entry>
    <title><![CDATA[java 笔记]]></title>
    <url>%2F2019%2F04%2F20%2Fjava%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[数据类型和运算符 标识符常作用 常量、变量、方法、类和包等的名称 命名规则 必须以字母、_下划线、美元符$开头。 其它部分可以是字母、下划线“_”、美元符“$”和数字的任意组合 大小写敏感，长度无限制。 不可以是Java的关键字。 注意 Java不采用通常语言使用的ASCII字符集 Java采用unicode这样的标准的国际字符集。因此，这里的字母的含义：英文、汉字等等。(不建议大家使用汉字来定义标识符！） 常量和变量常量变量定义 在程序中存在大量的数据来代表程序的状态，其中有些数据在程序的运行过程中值会发生改变，有些数据在程序运行过程中值不能发生改变，这些数据在程序中分别被叫做变量和常量。 变量举例： 在2D游戏程序中，需要代表人物的位置，则需要2个变量，一个是x坐标，一个是y坐标，在程序运行过程中，这两个变量的值会发生改变 常量举例 代表常数，便于程序的修改（例如：圆周率的值） 增强程序的可读性（例如：常量UP、DOWN、LEFT和RIGHT分辨代表上下左右，其数值分别是1、2、3和4） 在实际的程序中，可以根据数据在程序运行中是否发生改变，来选择应该是使用变量代表还是常量代表 数据类型byte：Java中最小的数据类型，在内存中占8位(bit)，即1个字节，取值范围-128~127，默认值0 short：短整型，在内存中占16位，即2个字节，取值范围-32768~32717，默认值0 int：整型，用于存储整数，在内在中占32位，即4个字节，取值范围-2147483648~2147483647，默认值0 long：长整型，在内存中占64位，即8个字节-2^63~2^63-1，默认值0L float：浮点型，在内存中占32位，即4个字节，用于存储带小数点的数字（与double的区别在于float类型有效小数点只有6~7位），默认值0 double：双精度浮点型，用于存储带有小数点的数字，在内存中占64位，即8个字节，默认值0 char：字符型，用于存储单个字符，占16位，即2个字节，取值范围0~65535，默认值为空 boolean：布尔类型，占1个字节，用于判断真或假（仅有两个值，即true、false），默认值false 浮点型变量：float类型：单精度类型，尾数可以精确到7位有效数字，在很多情况下，float类型的精度很难满足需求。 double类型：双精度类型 精度是float类型的两倍，尾数可以精确到16位有效数字，绝大部分应用程序都采用double类型。 注意 浮点常量默认为double。要变为float，需在后面增加F/f. 如： 3.14F 浮点数存在舍入误差，很多数字不能精确表示。如果需要进行不产生舍入误差的精确数字计算，需要使用BigDecimal类。 算术 单目：~（按位取反）、! (取非)、-（负号运算符）、 ++（自增）、 - -（自减）、 双目：+ - * / %（取余） 三目：a&gt;b?true:false 说明：当a大于b的时候，为true（也就是冒号之前的值），否则为false；这整个运算符包括一个关系运算符（可以是“&gt;””&lt;””!=”等等），一个“？”，一个“：”，冒号前后需要有两个或者是值或者是对象。 关系 等于符号:==，不等于符号:!= ，大于符号:&gt;， 小于符号:&lt;，大于等于符号 :&gt;= ，小于等于符号:&lt;= 。 *位与逻辑 位运算符 与（&amp;）、非（~）、或（|）、异或（^） &amp;：双目运算符，运算时均把运算数转换为二进制再做比较，规则：当相同的位上均为1时结果为1，否则结 果为0.如：1010&amp;1101，转为二进制：1111110010&amp;10001001101，比较结果为：1000000转为十进制： 64。所以1010&amp;1101=64； | ：当两边操作数的位有一边为1时，结果为1，否则为0。如1100|1010=1110 ~：0变1,1变0 ^：两边的位不同时，结果为1，否则为0.如1100^1010=0110 逻辑运算符 与（&amp;&amp;）、非（!）、或（||） 赋值 = += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= 基本数据类型的类型转换 在赋值运算或算术运算时，要求数据类型相同，否则要进行类型转换 转换方式： 自动转换 强制转换 除boolean类型外，所有的基本数据类型因为各自的精度不同，赋值时都要考虑这个问题 除boolean类型外，所有的基本数据类型包括：整型，浮点型，字符型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package 类型转换;/** * 基本数据类型的类型转换 * @author tang * * 类型转换分为两种情况 * 一，自动类型转换 * 1，低精度 向高精度转换 * 2，低位向高位转换 * 二，强制类型转换 * 1，高精度向低精度转换 * 可能会损失精度 * 2，高位向低位转换 * 可能会损失大小 * */public class Test &#123; public static void main(String[] args) &#123; int a = 10; float f = 1.23f; f = a; long lo = 123L; //__________________________ int b = 270; byte bt = (byte)b; System.out.println(bt); //00000001 00001110 f = 3.14f; int c = (int)f; System.out.println(c); &#125;&#125;package test;import java.util.Scanner;/** * 练习3:商场推出幸运抽奖活动 根据抽奖规则计算会员卡号各位数字之和为16,则为幸运会员 * @author tang * */public class Test03 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入四位数的会员卡卡号&quot;); //接收到用户输入的卡号 int cardNo = input.nextInt(); //求出卡号千位上的数字 int k = cardNo/1000; //求出卡号百位上的数字 int b = (cardNo%1000)/100; //求出卡号十位上的数字 int s = (cardNo%100)/10; //求出卡号个位上的数字 int g = cardNo%10;// 求和 int sum = k + b + s + g; String message = (sum == 16)?&quot;恭喜你，中奖了！&quot;:&quot;很遗憾，本次没有中奖&quot;; System.out.println(message); ​]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle入门到删库01]]></title>
    <url>%2F2019%2F04%2F20%2Foracle%E5%85%A5%E9%97%A8%E5%88%B0%E5%88%A0%E5%BA%9301%2F</url>
    <content type="text"><![CDATA[oracle 是一种关系型数据库 1.使用scott用户登录，需要先解锁 （1）使用DBA登录 （2）解锁命令：alter user scott account unlock|lock; 常用命令 (a)sqlplus 1.sqlplus /nolog 不登录 匿名连接到数据库 首先做次操作 2.conn scott/tiger@orcl 3.show user 4.set linesize 150 5.set pagesize 20 6.Passw 修改密码 7.conn sys/abc123456@orcl as sysdba (b)alter user scott account unlock (a)统一密码：123 (b)使用管理账号 (c)sqplus 1.spool on 开始写入 1.spool d:/test.txt 写入路径 2.select * from emp; 查询结果 3.spool off 写入完毕 distinct 取出重复数据 出现在distinct 后面的所有字段都是重复的，系统才会认为这些数据是重复数据。 例子：select distinct e.sal from emp e where 后面的条件 – ＝，！＝,&lt;&gt;，&lt;,&gt;,&lt;=,&gt;=,any,some,all – 部门编号不是10的员工 例子：select *from emp e where e.deptno &lt;&gt; 10; – &gt;all（） 相当于是大于最大值 – &gt;some（） 相当于是大于最小值 – &gt; any() 是查询最大和最小值之间 例子：select * from emp e where e.sal &gt; any(2000,5000); is null 和 is not null – oracle 中 null ！= null – 所以判断某个字段是否为null 要用 is null 或 is not null – 查询奖金不为空的员工 例子：select *from emp e where e.comm is not null between x and y –查询薪资处于1000-2000之间的员工 例子：select *from emp e where e.sal between 1000 and 2000 in（list），not in（list） –查询部门编号不是10 和 20的员工 例子：select e.*from emp e where e.deptno not in(10,20) exists（sub－query） 子查询有数据则表达式返回true 则执行exists前面的查询语句 select from emp e where exists(select from emp e where 1 = 2) like _ ,%,escape ‘\‘ _\% escape ‘\’ – 将所有名字是以s开头的员工查询出来 – 模糊查询 _ 代表有一个不确定的字符 – % 有多个不确定的字符 列子：select e.ename from emp e where e.ename like ‘%\%%’ escape ‘\’ oracle里面的转义符是自定义的，用escape来定义自己想要的转义符 or 和 and –列出deptno为10或者30，并且工资&gt;2000的所有人。 – and 的优先级高于 or 例子：select *from emp e where (e.deptno = 10 or e.deptno = 30) and e.sal &gt; 2000 order by 按照单个列排序 –order by col 降序和升序 –order by col desc (asc) 按照多个列排序（优先级） –order by col1 desc(asc), col2 desc(asc) –union all 全集 不会去除重复数据 ​ select * from emp e where e.deptno = 10 ​ union all ​ select * from emp e where e.sal &gt; 2000 –union 并集（去重） ​ select * from emp e where e.deptno = 10 ​ union ​ select * from emp e where e.sal &gt; 2000 –intersect 交集 ​ select * from emp e where e.deptno = 10 ​ intersect ​ select * from emp e where e.sal &gt; 2000 –minus 差集 ​ select * from emp e where e.deptno = 10 ​ minus ​ select * from emp e where e.sal &gt; 2000 （NVL(comm,0) comm取空值时用0替代） 例子： select e.ename,(e.sal+nvl(e.comm,0))*12 年收入 from emp e 字符函数 – dual 称之为虚表 用于检测查询语句的语法 – 拼接两个字符串 select concat(‘hello’, ‘nihao’) from dual – 首字母大写 select initcap(e.ename) from emp e – 字符搜索 select instr(‘abcda’,’a’,1,2) from dual –字符串左填充 select lpad(‘abc’,10,’#’) from dual –字符串右填充 select rpad(‘abc’,10,’#’) from dual 日期函数 – 返回系统当前日期 例子：select sysdate from dual – 返回指定月数后的日期 例子：select e.ename,e.hiredate 入职日期,add_months(e.hiredate,6) 转正日期 from emp e – 获取本月最后一天的日期 select last_day(sysdate) from dual – 获取最近的周日 月初 年初 select sysdate 当时日期, round(sysdate) 最近0点日期, round(sysdate,’day’) 最近星期日, round(sysdate,’month’) 最近月初, round(sysdate,’q’) 最近季初日期, round(sysdate,’year’) 最近年初日期 from dual; – 获取本周周日 本月月初 本年年初 select sysdate 当时日期, trunc(sysdate) 今天日期, trunc(sysdate,’day’) 本周星期日, trunc(sysdate,’month’) 本月初, trunc(sysdate,’q’) 本季初日期, trunc(sysdate,’year’) 本年初日期 from dual; — 转换函数 将数字转换为字符串 — 参数1 需要转换为字符串的数字 — 参数2 是规定转换得到的字符串的格式 select to_char(12345,’99,999.99’) from dual – 将日期转换为字符串 select to_char(sysdate,’yyyy-MM-dd HH:mi:ss’) from dual ; select to_char(sysdate,’d’) from dual; – to_date 将表示日期的字符串转换为日期类型 select to_date(‘2018年11月8日’,’YYYY”年”MM”月”DD”日”‘) from dual select to_date(‘2018-11-8’,’YYYY-MM-DD’) from dual Select to_date(‘04,05,19,10,23,40’,’yy,mm,dd,hh12,mi,ss’) from dual; – to_number select to_number(‘$123,456’,’999,999’) from dual — 单行函数嵌套 — 没有上司的人 写为boss select e.ename,nvl(to_char(e.mgr),’boss’) from emp e where e.mgr is null]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 笔记3]]></title>
    <url>%2F2019%2F04%2F20%2Fjava%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[​ 流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块。其流程控制方式采用结构化程序设计中规定的三种基本流程结构，即：顺序结构、分支结构和循环结构，如下图所示： 图示： ​ ​​ if单分支选择结构​ if语句对条件表达式进行一次测试，若测试为真，则执行下面的语句，否则跳过该语句​​ 图示： 12 12345678910111213141516171819202122package ifdemo;public class Test &#123; public static void main(String[] args) &#123; double n1 = 6*Math.random(); double n2 = 6*Math.random(); double n3 = 6*Math.random(); int sum = (int)(n1 + n2 + n3); if (sum &gt;= 15) &#123; System.out.println(&quot;今天手气不错&quot;); &#125; if (sum &gt;= 10 &amp;&amp; sum &lt; 15) &#123; System.out.println(&quot;今天手气一般&quot;); &#125; if (sum &lt; 10) &#123; System.out.println(&quot;今天手气不好&quot;); &#125; System.out.println(&quot;今日运势:&quot;+sum); &#125; if-else**双分支选择结构**当条件表达式为真时，执行语句块1，否则，执行语句块2。也就是else部分图示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package ifdemo;import java.util.Scanner;/**抽奖说明 会员号的百位数字和随机数相等 则会幸运会员 输出 XXXX会员,您是幸运会员,否则输出 XXXX 谢谢您的支持 * @author tang * */public class Test02 &#123; public static void main(String[] args) &#123; //创建一个Scanner的变量 用于输入会员卡卡号 Scanner input = new Scanner(System.in); System.out.println(&quot;请输入会员卡卡号&quot;); int no = input.nextInt(); //获取会员卡百位数字 213 int b = (no%1000)/100; //生成一个0~9的随机数 int number = (int)(10*Math.random()); //判断会员卡卡号百位数字是否和随机数相等 if (b == number) &#123; System.out.println(no+&quot;恭喜您，中奖了&quot;); &#125;else &#123; System.out.println(no+&quot;很遗憾没中奖.谢谢惠顾&quot;); &#125; System.out.println(&quot;程序结束&quot;); &#125;&#125;——————————package ifdemo;import java.util.Scanner;/**小孩搬桌子: 年龄大于7岁可以搬桌子了,大于5岁且为男孩,也可以搬桌子了 否则不可以搬动桌子 你还太年轻了 * @author tang * */public class Test03 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入年龄&quot;); //输入年两 int age = input.nextInt(); System.out.println(&quot;请选择性别:1,男 2,女&quot;); //输入性别 int gender = input.nextInt(); if (age &gt;= 7) &#123; System.out.println(&quot;可以搬桌子&quot;); &#125; if (age &gt;= 5 &amp;&amp; age &lt; 7) &#123; if (gender == 1) &#123; System.out.println(&quot;五岁到七岁之间的男孩可以搬桌子&quot;); &#125;else &#123; System.out.println(&quot;五岁到七岁之间的女孩不可以搬桌子&quot;); &#125; &#125; if (age &lt; 5) &#123; System.out.println(&quot;你不可以搬桌子，太年轻&quot;); &#125; &#125;&#125; If-else if-else**多分支选择结构**if(布尔表达式1) { 语句块1； } else if(布尔表达式2) { 语句块2； }……… else if(布尔表达式n){ ​ 语句块n; } else { ​ 语句块n+1; } 逐条if语句进行判断，条件匹配，进入语句体，否则对if语句继续匹配 1234567891011121314151617181920212223242526272829303132333435363738package ifelseif;import java.util.Scanner;/** * 0~3 婴儿 好好吃奶 * 3~5 儿童 好好玩 * 6~22 少年 好好学习 * 23~60 中年 好好挣钱 * 60~80 中老年 好好补钙 * 80~ 老年 好好晒太阳 * @author tang * * 6~23 精力旺盛 时间充足 财力不足 * 24~60 精力旺盛 时间不足 财力充足 * 60~ 精力不足 时间充足 财力充足 */public class IfElseIf &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入年龄&quot;); int age = input.nextInt(); if (age &lt;= 3) &#123; System.out.println(&quot;婴儿，应该好好吃奶&quot;); &#125;else if(age &lt; 6)&#123; System.out.println(&quot;儿童，好好玩&quot;); &#125;else if(age &lt; 22)&#123; System.out.println(&quot;少年，要好好学习&quot;); &#125;else if(age &lt;= 60)&#123; System.out.println(&quot;中年，要好好工作&quot;); &#125;else if (age &lt;= 80) &#123; System.out.println(&quot;中老年，要补钙&quot;); &#125;else &#123; System.out.println(&quot;老年人，多晒晒太阳&quot;); &#125; System.out.println(&quot;程序结束&quot;); &#125;&#125; while**循环** 在循环刚开始时，会计算一次“布尔表达式”的值，若条件为真，执行循环体。而对于后来每一次额外的循环，都会在开始前重新计算一次。 语句中应有使循环趋向于结束的语句，否则会出现无限循环–––”死”循环。 图示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package whiledemo;/** * 循环4要素 * 1，初始化 * 2，条件判断 * 3，循环体 * 4，迭代 * @author tang * */public class WhileDemo &#123; public static void main(String[] args) &#123; int i = 0;//初始化操作 while(i &lt; 1000)&#123;//条件判断的操作 //循环体 System.out.println(i); //迭代 就是让条件判断趋向于false的操作 i ++; &#125; System.out.println(&quot;程序结束&quot;); &#125;&#125; ---------package test;import java.util.Scanner;/** * 练习3:商场推出幸运抽奖活动 根据抽奖规则计算会员卡号各位数字之和为16,则为幸运会员 * @author tang * */public class Test03 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入四位数的会员卡卡号&quot;); //接收到用户输入的卡号 int cardNo = input.nextInt(); //求出卡号千位上的数字 int k = cardNo/1000; //求出卡号百位上的数字 int b = (cardNo%1000)/100; //求出卡号十位上的数字 int s = (cardNo%100)/10; //求出卡号个位上的数字 int g = cardNo%10;// 求和 int sum = k + b + s + g; String message = (sum == 16)?&quot;恭喜你，中奖了！&quot;:&quot;很遗憾，本次没有中奖&quot;; System.out.println(message); &#125;&#125; switch**多分支选择结构**根据表达式值的不同执行许多不同的操作 switch (表达式) { case 值1 : 语句序列; [break]; case 值2: 语句序列; [break] ; ​ … … … … … [default: 默认语句 ;] } 1.switch语句会根据表达式的值从相匹配的执行，一直执行到break标签处 语句处或者是switch语句的末尾。与任一case值不匹配，则进入default语句(如果有的话) 2.只能处理等值条件判断的情况，且表达式必须为byte，short，int或char类型 ，String 不能是double,float. long 3.常量值必须是与表达式类型兼容的特定的一个常量 4.不允许有重复的case值 5.default子句为可选 123456789101112131415161718192021222324252627282930package switchdemo;/** * 随机生成一个字母，并且判断该字母的类型 * * @author tang * */public class Test &#123; public static void main(String[] args) &#123; int n = (int)(26*Math.random());//产生一个[0,25)的随机数 char flg = (char)(97+n);//产生一个字母 switch (flg) &#123; case &apos;a&apos;: case &apos;e&apos;: case &apos;i&apos;: case &apos;o&apos;: case &apos;u&apos;: System.out.println(&quot;产生了一个元音字母&quot;+flg); break; case &apos;w&apos;: case &apos;y&apos;: System.out.println(&quot;产生了一个半元音字母&quot;+flg); break; default: System.out.println(&quot;产生了一个辅音字母&quot;+flg); break; &#125; &#125;&#125; do-while:先执行，后判断。 while: 先判断，后执行。 While和dowhile的区别： Dowhile总是保证循环体会被至少执行一次！这是他们的主要差别 图示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package Test;import java.util.Scanner;/** * 从键盘输入某个十进制小数，转换成对应的二进制小数并输出。 * @author Administrator * */public class D2Bpoint &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入一个十进制的小数：&quot;); double d = input.nextDouble(); double mul = d; StringBuffer buffer = new StringBuffer(&quot;0&quot;); int count = 0; do&#123; double result = mul*2; int i = (int)result; buffer.append(i); count++; if(count == 7)&#123; break; &#125; mul = result - i; &#125;while(mul != 0); System.out.println(d+ &quot;转化成二进制小数位：&quot;+buffer); &#125;&#125;---------package Test;/** * 6.从键盘输入某个十进制整数数，转换成对应的二进制整数并输出。 * @author Administrator *用2整除十进制整数，可以得到一个商和余数；再用2去除商， *又会得到一个商和余数，如此进行，直到商为小于1时为止， *然后把先得到的余数作为二进制数的低位有效位， *后得到的余数作为二进制数的高位有效位，依次排列起来。 */import java.util.Scanner; public class Test10to2 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入一个十进制的整数：&quot;); int num = input.nextInt(); int num2 = num; String str = &quot;&quot;; do&#123; int div = num/2 ; int mod = num%2 ; str = mod + str; num = div; &#125;while(num != 0); System.out.println(num2+&quot;转换成二进制为：&quot;+str); &#125; &#125; for循环 •for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构 •语法形式 • for (初始表达式;布尔表达式;步进) { –循环体； •} •注意事项 –for循环在执行条件测试后，先执行程序部分，再执行步进。 –在for语句的初始化部分声明的变量，其作用域为整个for循环体 –“初始化”和“循环条件表达式”部分可以使用逗号来执行多个操作 –如果三个部分都为空语句（分号不能省），相当于一个无限循环 跳转语句—break和continue •在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中剩余的语句。(break语句还可用于多支语句switch中) •continue 语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。 跳转语句 —return return语句从当前方法退出，返回到调用该方法的语句处，并从该语句的下条语句处继续执行程序。 返回语句的两种格式（具体到方法时详细讲解） 1、return expression 返回一个值给调用该方法的语句。 返回值的数据类型必须和方法声明中的返回值类型一致或是精度低于声明的数据类型。 2、return 当方法声明中用void声明返回类型为空时，应使用这种返回类型，它不返回任何值。 •break –switch语句–循环语句 •continue –循环语句 •return–任何语句中，结束当前方法，和循环其实没有什么关系 •Continue 只能用于循环中 while do-while 执行了continue 以后 代码回到执行判断的地方,重新判断是否决定下一次执行 •在for循环中执行continue 直接跳到i++迭代处 多重循环（循环嵌套） 一个循环体内又包含另一个完整的循环结构 任何两种循环都可以相互嵌套 可以任意层次循环，但是一般不超过3层 多重循环执行过程 外层循环变量变化一次，内层循环变量要变化一遍 12345678910111213141516171819202122232425262728293031323334package duochongxunhuan;import java.awt.Choice;import java.util.Scanner;/**- 有5家衣服专卖店，每家最多购买3件。用户可以选择离开，可以买衣服。最后打印总共买了几件衣服 思路 外层循环控制去每个专卖店 内层循环控制买衣服过程 使用break退出内层循环- @author Administrator * */ public class BreakDemo &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int count = 0; for (int i = 1;i &lt; 5; i++)&#123; System.out.println(&quot;欢迎光临第&quot;+ i +&quot;家专卖店&quot;); for(int j = 0;j &lt; 3;j++ )&#123; System.out.print(&quot;要离开吗？（y/n)?&quot;); String choice = input.nextLine(); if(&quot;y&quot;.equals(choice))&#123; break; &#125; System.out.println(&quot;买了一件衣服&quot;); count++; &#125; System.out.println(&quot;离店结账&quot;); System.out.println(&quot; &quot;); &#125; System.out.println(&quot;总共买了&quot;+count+&quot;件衣服&quot;); &#125; &#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
